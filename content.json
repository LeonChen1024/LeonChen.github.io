{"pages":[{"title":"about","text":"","link":"/about/index-1.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"APP 版本控制","text":"版本管理是app的一个重要部分，他主要的用途有： 让用户了解当前的版本信息，了解升级或者降级信息等 不同的版本可能提供的服务和功能有所差别，版本信息可以给我们一个标志来识别当前版本可提供的服务和功能。 目录 设置版本信息 统一配置 Reference 设置版本信息官方推荐是在Gradle中进行版本设置，因为Gradle中设置的版本信息会在构建的时候合并到manifest文件中，并会替换掉manifest中有关版本信息的设置。并且在Gradle中进行设置的话还可以根据应用不同的Flavor进行不同的设置。 版本控制主要有这么两个属性： -versionCode ： 整数，是内部版本号，仅用于判断一个版本是否比另一个版本新，用户并不会看到。通常是跟随着发布版本增加该code。 -versionName : 字符串，用户能看到的版本号。 通常我们将这些设置放在gradle下的android {} 块内部使用defaultConfig {} 包裹它。要注意，如果你在productFlavors中定义了这些属性，他们会覆盖defaultConfig中的值。 1234567891011121314151617android { ... defaultConfig { ... versionCode 1 versionName &quot;1.0.0&quot; } productFlavors { a { ... versionName &quot;1.0.0&quot; } b { ... } }} 在android中使用 PackageManager 的 getPackageInfo(java.lang.String, int) 方法可以获取版本信息。 1234567891011public static String getVersion(Context context)//获取版本号 { try { PackageInfo pi=context.getPackageManager().getPackageInfo(context.getPackageName(), 0); return pi.versionName; } catch (NameNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); return context.getString(R.string.version_unknown); } } 1234567891011public static int getVersionCode(Context context)//获取版本号(内部识别号){ try { PackageInfo pi=context.getPackageManager().getPackageInfo(context.getPackageName(), 0); return pi.versionCode; } catch (NameNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); return 0; }} 如果使用 Instant Run，Android Studio 会自动将 versionCode 设置为 MAXINT，将 versionName 设置为 INSTANTRUN。 统一配置顺便说一下一个可以统一所有的配置在一个地方的方法，这样可以便于我们管理版本。首先在主工程的build.gradle里增加一个配置区 12345678910ext { // Sdk and tools minSdkVersion = 17 targetSdkVersion = 21 compileSdkVersion = 23 buildToolsVersion = &quot;23.0.3&quot; // App dependencies supportLibraryVersion = &apos;23.3.0&apos;} 然后在module的build.gradle里使用123targetSdkVersion rootProject.ext.targetSdkVersioncompile &quot;com.android.support:appcompat-v7:$rootProject.supportLibraryVersion&quot; 123456789101112/** * 判断当前应用是否是debug状态 */public static boolean isApkInDebug(Context context) { try { ApplicationInfo info = context.getApplicationInfo(); return (info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0; } catch (Exception e) { return false; }} 1234567891011121314151617/***检测其他应用是否处于debug模式。*/public static boolean isApkDebugable(Context context,String packageName) { try { PackageInfo pkginfo = context.getPackageManager().getPackageInfo( packageName, 1); if (pkginfo != null ) { ApplicationInfo info= pkginfo.applicationInfo; return (info.flags&amp;ApplicationInfo.FLAG_DEBUGGABLE)!=0; } } catch (Exception e) { } return false; } Referencehttps://developer.android.com/studio/publish/versioning.html","link":"/2018/04/13/APP-Version-Control/"},{"title":"Android 6.0的变化 （上）","text":"随着一系列新的特性以及功能， Android 6.0 (API level 23)包含了很多的系统变化以及API行为的变化。本文着重介绍了一些你应该理解的和占用APP中重要部分的变化。 如果你之前已经在Android平台发布过APP，要知道这些平台上的变化将会影响你的APP。 目录 目录 运行时权限 休眠和应用待机模式 移除Apache的 HTTP Client BoringSSL 获取硬件标识符 通知 AudioManager 改变 文本选择 运行时权限这个版本引入了一个新的权限模型，使得用户现在可以在运行时直接管理APP权限。这个模型改善了用户对权限管理的可见度和管理程度，并简化了APP开发者对安装和自动升级的流程。用户可以对已安装的APP的权限分别进行授权和取消。 当你的APP的目标版本在Android 6.0 (API level 23)或者更高的时候， 请确保在运行时检查并申请权限。要确定你的APP是否被授予了某权限，可以通过调用新的checkSelfPermission()方法。为了去申请一个权限，可以通过调用 requestPermissions() 新方法。即使你的APP目标版本不是 Android 6.0 (API level 23)，你也应该在新的权限模型下进行测试。 想要了解更多的在你的APP里支持新的权限模型的细节，可见 Working with System Permissions。获得更多的评估对你的APP的影响的提示，可见Permissions Best Practices。 危险权限和普通权限见下链接点击打开链接 休眠和应用待机模式这个版本将为空闲的设备和APP引入新的节能方式。这些新功能将会影响所有的APP，所以请确保你的APP在新的模式下进行测试。 休眠：如果用户拔出一个设备并将其屏幕关闭闲置一段时间，设备将会进入休眠模式，尝试使系统进入睡眠状态。在这个模式下，设备周期性的恢复短暂时间的正常操作使得APP可以进行同步，使得系统可以进行一些待执行的操作。 APP待机：APP待机允许系统判定一个APP是处于待机状态当这个APP没有被用户显式的使用。系统在用户一段时间内并没有触摸这个APP时做出这个决定。如果设备没有连接充电器，系统将会禁止访问网络并暂停APP的同步以及相应的工作当他被认为是闲置的时候。 学习更多的有关节能方面的改变，详见Optimizing for Doze and App Standby。 移除Apache的 HTTP ClientAndroid 6.0 的版本移除了对 Apache HTTP client的支持.如果你的APP正在使用这个client并且目标版本在Android 2.3 (API level 9)或者更高，请使用HttpURLConnection类来替代。这个API是更加高效的，因为他采用了透明压缩和响应缓存来减少网络使用，减少电能消耗。如果仍然想继续使用Apache HTTP APIs，你必须一开始就在你的build.gradle文件里定义以下编译时依赖。 123android { useLibrary &apos;org.apache.http.legacy&apos;} BoringSSLAndroid正在将OpenSSL替换为BoringSSL库。如果你的APP使用的是 Android NDK，请不要使用那些不属于NDK API里的库，比如：libcrypto.so 和 libssl.so.这些库不是公开的API,他们的修改和禁用也不会通过文件和设备通知开发者。另外，这样可能还会暴露你APP的安全漏洞。取而代之的是你需要修改你的native代码，通过JNI来调用Java cryptography APIs或者静态连接到你选择的加密库。 获取硬件标识符从这个版本开始，为了给用户提供更好点数据保护，Android删除了通过编程方式从Wi-Fi 和 Bluetooth APIs来获得硬件本地标识符的方法。现在 WifiInfo.getMacAddress() 和 BluetoothAdapter.getAddress()方法将始终返回一个常量值02:00:00:00:00:00。 为了通过蓝牙或WiFi扫描获取附近的设备的硬件标识符，你的APP必须拥有ACCESS_FINE_LOCATION 或 ACCESS_COARSE_LOCATION权限。 123WifiManager.getScanResults()BluetoothDevice.ACTION_FOUNDBluetoothLeScanner.startScan() 注意：当一个运行Android 6.0 (API level 23)的设备启动WiFi或者蓝牙扫描时，这个操作对外部设备是可见的，并会被初始化一个随机的mac地址。 通知这个版本删除了 Notification.setLatestEventInfo()方法。使用Notification.Builder来取代它进行构造通知。为了反复更新一个通知，可以重用 Notification.Builder 实例，调用 build() 方法来更新通知实例。 adb shell dumpsys notification命令不在打印你的通知文本。使用adb shell dumpsys notification –noredact命令来取代它打印你的通知对象文本。 AudioManager 改变不再支持通过 AudioManager类来对某个音频流进行精确的调音或者静音设置。 setStreamSolo()方法已经被弃用了，你应该使用 requestAudioFocus() 方法来替代它。同样的setStreamMute()方法也被弃用了，调用 adjustStreamVolume() 方法来替代它，传入的参数变为ADJUST_MUTE 或 ADJUST_UNMUTE 。 文本选择当用户在你的APP上选择文本时，你现在可以在浮动工具栏里显示一些文本选择动作比如剪切，复制，和粘贴。和用户的交互界面类似于上下文动作菜单，就像为单独的视图配置的上下文菜单。 为了实现文本选择的浮动工具栏，需要在你已有的APP里做出以下改变： 1.在你的view里或者activity里，改变你的 ActionMode 的获取方法，由startActionMode(Callback)变为 startActionMode(Callback, ActionMode.TYPE_FLOATING). 2.将你已经实现了ActionMode.Callback变为继承自ActionMode.Callback2。 3.重写 onGetContentRect()方法来提供视图中内容选中框（比如文本选中框）的坐标。 4.在矩形框作为一个唯一的元素不再有效时，调用 invalidateContentRect() 方法。 如果你在使用 Android Support Library revision 22.2, 你要知道浮动工具栏并不向后支持并且APP兼容会默认控制 ActionMode。这会阻止悬浮工具栏的显示。为了实现在 AppCompatActivity 里对 ActionMode的支持，调用 getDelegate()方法，并用其得到的 AppCompatDelegate 对象调用setHandleNativeActionModesEnabled()并将传入参数设为false。这个调用返回 ActionMode的控制给框架。在设备运行Android 6.0 (API level 23),这允许框架去支持 ActionBar 或者浮动工具栏模式，而当设备运行早Android 5.1 (API level 22)或更低的版本上时，只有 ActionBar 模式被支持。","link":"/2016/08/20/Android-6.0-Change-1/"},{"title":"Android 6.0的变化 （下）","text":"目录 目录 浏览器书签变化 Android密钥库变化 wifi和网络工作的变化 照相服务改变 运行时 APK验证 USB连接 企业级Android的变化 DevicePolicyManager api的变化： 其他API的变化： 全局设置的变化： 浏览器书签变化这个版本移除了对全局书签的支持。android.provider.Browser.getAllBookmarks()and android.provider.Browser.saveBookmark() 方法现在被移除了。同样的，READ_HISTORY_BOOKMARKS and WRITE_HISTORY_BOOKMARKS 权限也被移除了。如果你的APP目标版本是Android 6.0 (API level 23) 或者更高，不要使用全局书签或使用全局书签的权限，相对应的，你的APP应该使用内部的书签。 Android密钥库变化在这个版本， Android Keystore provider 不在支持DSA.ECDSA仍然被支持。当安全锁屏被禁用或复位时（例如，被用户或设备管理器操作时），那些没加密的密钥将不再被删除，在这些时候那些加密的密钥将被删除。 wifi和网络工作的变化这个版本介绍了一下几个有关于Wi-Fi 和网络工作的API的行为变化。 你的APP现在可以改变 WifiConfiguration 对象的状态仅当是你创建了这些对象时。你将不被允许去修改或者删除WifiConfiguration 对象当他是被用户或者别的APP创建的。 在之前，如果一个APP使用 enableNetwork() 方法并设置disableAllOthers=true 来强制设备连接某个指定的WiFi网络，设备将会拒绝连接其他的网络比如蜂窝数据。在这个版本，设备不在拒绝连接其他的网络。如果你的APP的targetSdkVersion 是20或者更低，他将被固定在所选的WiFi网络。如果你的APP的targetSdkVersion 是21或者更高，使用多网络API（例如 openConnection(), bindSocket(),和新的bindProcessToNetwork() 方法）来确保网络通信是使用被选择的网络。 照相服务改变在这个版本中，接收摄像头服务和共享资源的模式已经从原来的“先到先服务”的模式转变为先服务高优先级的进程，服务的行为改变包括： 获取相机子系统的资源，包括打开和配置相机设备，是基于APP进程的“优先级”来进行授予的。用户可见的或者在最前的activity的APP进程通常给予较高的优先级，来使的相机资源的分配和使用更加的可靠。 一个低优先级的APP的正在使用相机的用户可能会被“驱逐”当一个高优先级的APP尝试使用相机时。在被弃用的Camera API中，这将导致被驱逐的用户将会调用 onError() 方法，而在Camera2 API中，这将导致被驱逐的用户调用 onDisconnected() 方法。 当设备拥有合适的照相机硬件时，不同的APP进程可以独立的打开和使用照相机设备。然而，多进程使用的情况下，当同时请求导致对任意的相机设备的性能和能力的降低，现在的相机服务对此进行检测并且禁止改行为。这样的改变可能导致低优先级的用户被“驱逐”即使没有其他的APP明确的尝试访问相同的相机设备。 改变当前的用户会导致之前的用户中的APP的活动的相机用户被驱逐。访问相机应用将被限制于用户配置文件属于当前设备用户者。在实践中，这就比如说是一个“游客”账户，当用户切换了一个不同的账号时将无法离开正在运行的相机子系统的进程。 运行时ART运行时可以正确的实现访问 newInstance()方法的规则。这种改变解决了以前版本中Dalvik 检查访问规则错误的问题。如果你的APP调用了 newInstance()方法并且你想要重写访问检查，应该调用 setAccessible()并将传入参数设为true。如果你的APP使用了v7 appcompat library 或者 v7 recyclerview library 包，你必须在你的APP里更新这些相应的包到最新版。此外，确保你的xml中引用的自定义类已经更新来保证他们的类构造器可用。 这个版本更新了动态连接器的行为。动态链接器现在可以识别库的soname和他的路径的不同（公共bug6670），并且实现了通过soname来进行查找的功能。在加载的时候那些先前工作在坏的 DT_NEEDED 的项目（在创建机器文件系统时使用绝对路径）可能会失败。 现在已经支持方法dlopen(3) RTLD_LOCAL模式，需要注意的是RTLD_LOCAL是默认值，当你没有明确使用其他参数时将不会影响到默认值。（除非你的APP明确的使用了 RTLD_GLOBAL）。在使用RTLD_LOCAL的情况下，比较晚使用dlopen(3）进行库加载的标识符将不可用。 在Android之前的版本里，如果你要求系统加载一个文本重定位的共享库文件，系统会显示警告但是仍然会允许加载该库。从这个版本开始，如果你的APP的目标sdk是23或者更高系统将会拒绝该库。为了帮助你检测到库文件的加载失败，你的APP应该打印有关日志来记录dlopen()失败，包括记录问题的描述以及dlerror返回。为了学习更多的有关文本重定位的内容可见这个指导。 APK验证现在平台执行严格的apk验证。一个在manifest中声明了某文件但是在apk中却没有出现该文件的apk被认为是损坏的。一个apk中的任何内容被修改后必须重新签名。 USB连接设备通过USB端口进行连接现在默认设置为仅充电模式。为了通过USB连接方式访问设备及其内容，用户必须明确的授予这种交互的权限。如果你的应用支持通过USB端口进行交互，请考虑到该交互必须显示的启用。 企业级Android的变化在这个版本包括了以下企业级Android的行为变化。 个人环境中的企业通讯录。当用户查看过去的通话记录时，google拨号器将会显示企业通讯录。设置setCrossProfileCallerIdDisabled() 为true来使得在google拨号器里隐藏企业联系人记录。当通过蓝牙分享时工作通讯录将会和个人通讯录一起显示，除非你 setBluetoothContactSharingDisabled() 为false。在默认情况下，它是设置为true的。 WiFi配置清除：通过Profile Owner来添加Wi-Fi配置（例如，调用addNetwork()方法）在它对应的企业配置文件被移除后删除。 WiFi配置锁定：如果WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN 不为0时，任何由活动设备拥有者创建的WiFi配置文件将不可以被用户进行修改和删除。用户仍然可以创建和修改他们自己的WiFi配置。活动设备所有者拥有修改和删除包括那些不是由他们创建的WiFi配置的特权。 通过google账号来下载企业策略控制器：当一个管理环境之外的需要管理的google账号要求通过设备策略控制器app添加到设备时，新增账号流程将会提示用户安装合适的WPC。这一行为同样支持通过设置-账号和初始化设备时添加账号。 DevicePolicyManager api的变化：调用 setCameraDisabled()方法只会影响当前调用相机的用户。从管理文件中调用的话并不影响正在主用户上运行的使用相机的APP。 此外，现在配置拥有者可以和设备拥有者一样使用setKeyguardDisabledFeatures() 方法。 配置拥有者可以设置以下锁屏设置：KEYGUARD_DISABLE_TRUST_AGENTS 和 KEYGUARD_DISABLE_FINGERPRINT可以影响配置文件的父用户。KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS,会影响APP在管理文件中产生的通知。 DevicePolicyManager.createAndInitializeUser() 和DevicePolicyManager.createUser()方法被弃用。 setScreenCaptureDisabled() 方法现在也会阻塞辅助框架当给定的用户在前台活动时。 EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM 现在默认SHA-256。SHA-1 现在仍然支持向后兼容但是以后将会被删除。 EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM现在只接受SHA-256。 Android 6.0 (API level 23)中的 Device initializer API 现在被删除了。 EXTRA_PROVISIONING_RESET_PROTECTION_PARAMETERS 被移除，所以NFC触碰配置不能以编程解锁一个恢复出厂设置保护的设备。 你现在可以使用EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE在NFC触碰时将管理设备的数据传输给设备拥有者的APP。 企业Android api 优化了M的运行时权限，包括工作文件，协助层，以及其他等等。新的 DevicePolicyManager 权限API不影响Android M 之前的APP版本。 当用户从初始化设置流程中通过ACTION_PROVISION_MANAGED_PROFILE 或 ACTION_PROVISION_MANAGED_DEVICE intent退出同步部分，系统现在会返回一个RESULT_CANCELED返回值。 其他API的变化：数据流量统计:android.app.usage.NetworkUsageStats 类被重命名为 NetworkStats. 全局设置的变化：以下属性将不能再通过 setGlobalSettings()来设置：BLUETOOTH_ONDEVELOPMENT_SETTINGS_ENABLEDMODE_RINGERNETWORK_PREFERENCEWIFI_ON 以下全局设置现在可以使用setGlobalSettings()来设置：WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN","link":"/2016/08/20/Android-6.0-Change-2/"},{"title":"Android 相关错误及解决办法","text":"目录 目录 问题 : Unable to instantiate activity ComponentInfo{com.xxxx.xxxx/com.xxxx.xxxx.LoginActivity} 问题 : Unable to instantiate activity ComponentInfo{com.xxxx.xxxx/com.xxxx.xxxx.LoginActivity}java.lang.RuntimeException: Unable to instantiate activity ComponentInfo{com.xxxx.xxxx/com.xxxx.xxxx.LoginActivity}: java.lang.ClassNotFoundException: Didn’t find class “com.xxxx.xxxx.LoginActivity” on path: /data/app/com.xxxx.xxxx-1. 解决方法 : 原因AndroidManifest.xml文件出错。将问题Activity的name具体到某个包下即可运行。android:name=”.LogoActivity”改为android:name=”.ac.LogoActivity”.","link":"/2018/01/10/Android-Error-And-Solution/"},{"title":"Android declare-styleable自定义属性","text":"我们自己定义view，通常继承View，重写构造方法和onDraw等函数，然后具体实现自己定义的复杂view。但是继承这个自定义view的有的属性又各有不同，有的属性在原生属性中没有，这时候就可以使用自定义的属性来便捷的设置相应的属性。 1、在res/values/下新建一个attrs.xml文件。写入这三级标签。并填入相应属性。 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"myStyle\"&gt; &lt;attr name=\"textSize\" format=\"dimension\" /&gt; &lt;attr name=\"backgroud\" format=\"reference\" /&gt; &lt;attr name=\"text\" format=\"string|reference\" /&gt; &lt;attr name=\"textColor\" format=\"color\" /&gt; &lt;attr name=\"yesOrNot\" format=\"boolean\" /&gt; &lt;attr name=\"number\"&gt; &lt;enum name=\"one\" value=\"0\" /&gt; &lt;enum name=\"two\" value=\"1\" /&gt; &lt;enum name=\"leftToRight\" value=\"2\" /&gt; &lt;enum name=\"topToBottom\" value=\"3\" /&gt; &lt;/attr&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 2、建立一个自定义视图类，本次偷懒直接继承自textview。然后使用typedarray类来获取控件相应的属性并使用。 123456789101112131415161718192021222324252627282930import android.content.Context;import android.content.res.TypedArray;import android.graphics.Color;import android.graphics.drawable.Drawable;import android.util.AttributeSet;import android.widget.TextView;public class MyView extends TextView{ public MyView(Context context, AttributeSet attrs) { super(context, attrs); TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.myStyle); float textSize = typedArray.getDimension(R.styleable.myStyle_textSize, 15); Drawable back = typedArray.getDrawable(R.styleable.myStyle_backgroud); String textString = typedArray.getString(R.styleable.myStyle_text); int textColor = typedArray.getInt(R.styleable.myStyle_textColor, Color.BLACK); boolean yesOrNot = typedArray.getBoolean(R.styleable.myStyle_yesOrNot, true); int number = typedArray.getInt(R.styleable.myStyle_number, 0); setTextSize(textSize); setText(textString); setBackgroundDrawable(back); setTextColor(textColor); }} 3、在布局文件里引用该类，并设定相应的属性。记得要定义xmlns:myapp（后面的名称随意取，但要上下一致。）= “http://schemas.android.com/apk/res/com.example.declarestyleabletest&quot;（最后是该自定义视图类所在的包名） 1234567891011121314151617181920&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:myapp=\"http://schemas.android.com/apk/res/com.example.declarestyleabletest\" android:id=\"@+id/container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"com.example.declarestyleabletest.MainActivity\" tools:ignore=\"MergeRootFrame\" &gt; &lt;com.example.declarestyleabletest.MyView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" myapp:backgroud=\"@drawable/ic_launcher\" myapp:number=\"one\" myapp:text=\"sdfkks\" myapp:textColor=\"@color/black\" myapp:textSize=\"15sp\" /&gt;&lt;/LinearLayout&gt; 补充一些常用的format reference 指定某资源IDstring 字符串dimension 尺寸color 颜色boolean 布尔integer 整型float 浮点型fraction 百分数enum 枚举flag 位运算 xml 中定义好自己的属性值，在在代码中得到值，或使用默认值 1234567891011121314public CText(Context context, AttributeSet set) { super(context, set); this.context = context; initView(); TypedArray array = context.obtainStyledAttributes(set,R.styleable.CEditText); initAttrs(array); } private void initAttrs(TypedArray a) { hint = a.getString(R.styleable.CEditText_cHint); text = a.getString(R.styleable.CEditText_cText); setAttrs(); a.recycle(); }","link":"/2016/03/17/Android-declare-styleable-Attribute/"},{"title":"Binary Search(二分搜索)","text":"Binary Search(二分搜索)二分搜索(binary search),也叫做 折半搜索(half-interval search),对数搜索(logarithmic search),对半搜索(binary chop),是一种在有序数组中查找某一特定元素的搜索算法. 二分搜索有几个变体.特别是,分散层叠(fractional cascading)(将每个数组里的值集合成一个数组,元素为11[0,3,2,0] 的形式,括号内的数字是该值在对应数组中应该返回的数字)提高了在多个数组中查找相同值的效率,高效的解决了一系列计算几何和其他领域的查找问题).指数查找(Exponential search)延伸了二分查找到一个没有边界的 list.binary search tree和B-tree是基于 binary search 延伸的. 原理搜索时从数组中间元素开始,如果中间元素正好是要查找的元素,则搜索过程结束;如果中间元素大于或者小于要查找的元素,则在数组中大于或者小于查找元素的一半中继续查找,重复这个过程直到找到这个元素,或者这一半的大小为空时则代表找不到.这样子每一次比较都使得搜索范围缩小一半. 步骤给定一个有序数组 A 是 A0,…,An-1并保证 A0&lt;=…&lt;=An-1,以及目标值 T. 令 L 为0,R 为 n-1. 如果 L&gt;R 则搜索失败 令m(中间值元素索引)为最大的小于(L+R)/2的整数 如果 Am&lt;T ,令 L=m+1并回到第2步; 如果 Am&gt;T ,令 R=m-1并回到第2步; 当 Am=T,搜索结束;T 所在的索引位置为m. 变体 令 L 为0,R 为 n-1. 令 m(中间元素索引) 为上限,也就是最小的大于(L+R)/2的值. 如果 Am&gt;T ,设置 R 为 m-1并且返回第2步 如果 Am&lt;=T ,设置 L 为m 并且返回第2步. 直到 L=R ,搜索完成.这时候如果T=Am,返回 m,否则,搜索失败. 在 Am&lt;=T 的时候,这个变体将 L 设置为 m 而不是 m+1.这个方式的比较是更快速的,因为它在每个循环里省略了一次比较.但是平均就会多出来一次循环.在数组包含重复的元素的时候这个变体总是会返回最右侧的元素索引.比如 A 是[1,2,3,4,4,5,6,7]查找的对象是4,那么这个方法会返回 index 4,而不是 index 3. 大致匹配由于有序数组的顺序性,可以将二分搜索扩展到大致匹配.可以用来计算赋值的排名(或称秩,比它更小的元素的数量),前趋(下一个最小元素),后继(下一个最大元素)以及最近邻.还可以使用两个排名查询来执行范围查询. 排名查询可以使用调整后的二分搜索来进行.成功时返回m,失败时返回 L, 这样就等于返回了比目标值小的元素数目. 前趋和后继可以使用排名查询来进行.当知道目标值的排名,成功时前趋是排名位置的上一个元素,失败时则是排名位置的元素.它的后继是排名位置的后一个元素,或是前趋的下一个元素.目标值的最近领可能是前趋或后继,取决于哪个更接近目标值. 范围查询,一旦知道范围两边的值的排名,那么大于边界最小值且小于边界最大值的元素排名就是他们的范围,是否包含边界值根据需要处理. 性能分析时间复杂度二分查找每次把搜索区域减少一半,时间复杂度为$$O(log_2 n)$$(n 是集合中元素的个数)最差的情况是 遍历到最后一层,或者是没有找到该元素的时候,复杂度为 $O(\\lfloor log_2 n + 1 \\rfloor)$ . 综合复杂度为 $O(log_2 n)$ 分散层叠(fractional cascading) 可以提高在多数组中查询相同值的效率. k 是数组的数量,在每个数组中查询目标值消耗 $O(k log n)$ 的时间.分散层叠可以将它降低到 $O(k+log n)$. 变体效率分析相对于正常的二分搜索,它减少了每次循环的比对次数,但是它必须做完完整的循环,而不会在中间就得到答案.但是在 n 很大的情况下减少了对比次数的提升不能够抵消多余的循环的消耗. 空间复杂度O(1).尾递归,可以改写为循环. 应用查找数组中的元素,或用于插入排序. 二分搜索和其他的方案对比使用二分搜索的有序数组在插入和删除操作效率很低,每个操作消耗 O(n) 的时间.其他的数据结构提供了更高效的插入和删除,并且提供了同样高效的完全匹配.然而,二分搜索适用于很多的搜索问题,只消耗 $O(log n)$ 的时间. Hashing对于关联数组 (associative arrays),哈希表 (hash tables),他们是通过hash 函数将键映射到记录上的数据结构,通常情况下比在有序数组的情况下使用二分查找要更快.大部分的实现平均开销都是常量级的.然而, hashing 并不适用于模糊匹配,比如计算前趋,后继,以及最近的键,它在失败的查询情况下能给我们的唯一信息就是目标在记录中不存在.二分查找是这种匹配的理想模式,消耗对数级别的时间. Trees二叉搜索树(binary search tree) 是一个基于二叉搜索原理的二叉树(binary tree)数据结构.树的记录按照顺序排列,并且每个树里的每个记录都可以使用类似二叉搜索的方法来搜索,平均耗费对数级的时间.插入和删除的平均时间也是对数级的.这会比有序数组消耗的线性时间要快,并且二叉树拥有所有有序数组可以执行的操作,包含范围和模糊查找. 然而二叉搜索通常情况下比二叉搜索树的搜索更有效率,因为二叉搜索树很可能会完全不平衡,导致性能稍差.这同样适用于 平衡二叉搜索树( balanced binary search trees) , 它平衡了它自己的节点稍微向完全平衡树靠拢.虽然不太可能,但是树有可能只有少数节点有两个子节点导致严重不平衡,这种情况下平均时间损耗和最差的情况差不多都是 O(n) .二叉搜索树比有序数组占用更多的空间. 二叉搜索树因为可以高效的在文件系统中结构化,所以他们可以在硬盘中进行快速搜索.B-tree 泛化了这种树结构的方法.B-tree 常用于组织长时间的存储比如数据库(databases)和文件系统(filesystems). Linear search线性搜索( Linear Search)是一种简单的搜索算法,它查找每一个记录直到找到目标值.线性搜索可以在 链表(linked list) 上使用,它的插入和删除会比在数组上要快.二分搜索比线性搜索要快除非数组很短.如果数组必须先被排序,这个消耗必须在搜索中平摊.对数组进行排序还可以进行有效的近似匹配和其他操作. Set membership algorithms一个和搜索相关的问题是集合成员(set membership).所有有关查找的算法,比如二分搜索,都可以用于集合成员.还有一些更适用于集合成员的算法,位数组(bit array)是最简单的一个,在键的范围是有限的时候非常有用.它非常快,是需要O(1)的时间.朱迪矩阵(Judy array)可以高效的处理64位键. 对于近似结果,布隆过滤器(Bloom filters)是另外一个基于哈希的概率性数据结构,通过存储使用bit array 和多重 hash 函数编码的键集合. Bloom filters 在大多数情况下空间效率比bit arrays 要高而不会慢太多:使用了 k 重hash 函数,成员查找只需要 O(k) 的时间.然而, Bloom filters 有一定的误判性. 其他的数据结构这里存在一些数据结构在某些情况下比在有序数组上使用二分搜索进行查找或其他的操作更加高效.比如,在van Emde Boas trees, fusion trees, 前缀树(tries), 和位数组 上进行查找,近似匹配,以及其他可用的操作可以比在有序数组上进行二分搜索更加的高效.然而,尽管这些操作可以比在无视键的情况下比有序数组上使用更高效,这样的数据结构通常是因为利用了某些键的属性(键通常是一些小整数),因此如果键缺乏那些属性将会消耗更多的空间或时间.一些结构如朱迪矩阵,使用了多种方式的组合来保证效率和执行近似匹配的能力. 变体Uniform binary searchUniform binary search 不是存储下限和上限的边界值,而是中间元素的索引,和从这次循环的中间元素到下次循环的中间元素的变化.每一步的变化减少一半.比如,要搜索的数组是[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],中间元素是6.Uniform binary search 同时对左边和右边的子数组进行操作.在这个情况下,左边的子数组([1, 2, 3, 4, 5]) 的中间元素 3 而右边的子数组 ([7, 8, 9, 10, 11]) 的中间元素是 9.然后存储3 作为两个中间元素和 6 的差别.为了减少搜索的空间使用,算法同时加上或减去这个和中间元素的改变.这个算法的好处是可以将每次循环的索引的差别存储到一个表里,在某些系统里可以提高算法的性能. Exponential search指数查找(Exponential Search)将二分搜索拓展到无边界数组.它最开始寻找第一个索引是2的幂次方并且要比目标值大的元素的索引.然后,它将这个元素索引设置为上边界,然后开始二分搜索.指数查找消耗 $\\lfloor log_2 x =1 \\rfloor$ 次循环 ,然后二分搜索消耗 $\\lfloor log_2 x \\rfloor$ 次循环, x 是目标值的位置.指数查找适用于有界列表,在目标值接近数组开始的位置的时候比二分查找性能有所提高. Interpolation search内插搜索(Interpolation search)忽略了目标值的位置,计算数组的最低和最高元素的距离即数组的长度.这只有在数组元素是数字的时候才能使用.它适用于中间值不是最好的猜测选择的情况.比如,如果目标值接近数组的最高元素,最好是定位在数组的末端.如果数组的分布是均匀的或者接近均匀的,它消耗 $O(log log n)$ 次比较. 实际上,内插搜索在数组元素较少的情况下是比二分搜索更慢的,因为内插搜索需要额外的计算.尽管它的时间复杂度增长是小于二分搜索的,只有在在大数组的情况下这个计算的损耗可以被弥补. Fractional cascading分散层叠(Fractional cascading) 可以提高在多个有序数组里查找相同的元素或近似匹配的效率,分别在每个数组里查找总共需要 $O(klogn)$的时间, k 是数组的数量.分散层叠通过将每个数组的信息按指定的方式存储起来将这个时间降低到 $O(k+logn)$ . 它将每个数组里的值集合成一个数组,元素为 11[0,3,2,0] 的形式,括号内的数字是该值在对应数组中应该返回的数字)提高了在多个数组中查找相同值的效率,高效的解决了一系列计算几何和其他领域的查找问题 分散层叠被发明的时候是为了高效的解决各种计算几何学(computational geometry) 问题,但是它同样适用于其他地方,例如 数据挖掘(data mining) 和 互联网协议(Internet Protocal) 等. 实现时的问题要注意中间值的取值方法,如果使用 (L+R)/2 当数组的元素数量很大的时候回造成计算溢出.所以要使用L+(R-L)/2. 示例C 版本- 递归12345678910111213int binary_search(const int arr[], int start , int end , int khey){ if (start &gt; end) return -1; int mid = start +(end - start)/2; //直接平均可能会溢位,所以用此算法 if (arr[mid] &gt; khey) return binary_search(arr , start , mid - 1 , khey); else if (arr[mid] &lt; khey) return binary_search(arr , mid + 1 , end , khey); else return mid; //最后才检测相等的情况是因为大多数搜寻情况不是大于就是小于} C 版本- while 循环 12345678910111213141516171819int binary_search(const int arr[], int start, int end, int khey){ int result = -1; //如果没有搜索到数据返回 -1 int mid; while (start &lt;= end){ mid = start + (end - start)/2 ; //直接平均可能会溢位,所以用此算法 if (arr[mid] &gt; khey) end = mid-1; else if (arr[mid] &lt; khey) start = mid + 1; else{ //最后才检测相等的情况是因为大多数搜寻情况不是大于就是小于 result = mid; break; } } return result;} Python3 递归 12345678910def binary_search(arr, start, end, hkey): if start &gt; end: return -1 mid = start + (end - start) / 2 if arr[mid] &gt; hkey: return binary_search(arr, start , mid - 1,hkey) if arr[mid] &lt; hkey: return binary_search(arr, mid + 1, end, hkey) return mid Python3 while 循环 1234567891011121314def binary_search(arr, start, end, hkey): result = -1 while start &lt;= end: mid = start + (end - start) / 2 if arr[mid] &gt; hkey : end = mid - 1 elif arr[mid] &lt; hkey : start = mid + 1 else : result = mid break return result Java 递归 123456789101112public static int binarySearch(int[] arr, int start, int end, int hkey){ if (start &gt; end) return -1; int mid = start + (end - start)/2; //防止溢位 if (arr[mid] &gt; hkey) return binarySearch(arr, start, mid - 1, hkey); if (arr[mid] &lt; hkey) return binarySearch(arr, mid + 1, end, hkey); return mid; } Java while 循环 12345678910111213141516171819public static int binarySearch(int[] arr, int start, int end, int hkey){ int result = -1; while (start &lt;= end){ int mid = start + (end - start)/2; //防止溢位 if (arr[mid] &gt; hkey) end = mid - 1; else if (arr[mid] &lt; hkey) start = mid + 1; else { result = mid ; break; } } return result;} About Me我的博客 leonchen1024.com 我的 GitHub https://github.com/LeonChen1024 微信公众号 Referenceshttps://en.wikipedia.org/wiki/Binary_search_algorithm","link":"/2018/08/14/Binary-Search/"},{"title":"Byte 常用转换","text":"思路:以 int 作为例子, 首先要知道他们的换算公式。 1 int = 4 byte ，1 byte = 8 bit , 一个 bit 是一位二进制。i 和 0xFF 取与得到最低位的 1byte 数据，然后将 i 右移8位再与 0xFF 取与得到第二低位的 1byte数据，以此类推。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/** * 将int转换为四个字节的byte数组，高位在前，低位在后 * * @param i 要转换的int参数 * * @return 四个字节的byte数组 */ public static byte[] intToHlBytes4(int i) { byte[] result = new byte[4]; result[3] = (byte) (i &amp; 0xFF); result[2] = (byte) ((i &gt;&gt; 8) &amp; 0xFF); result[1] = (byte) ((i &gt;&gt; 16) &amp; 0xFF); result[0] = (byte) ((i &gt;&gt; 24) &amp; 0xFF); return result; } /** * 将int转换为四个字节的byte数组，低位在前，高位在后 * * @param i 要转换的int参数 * * @return 四个字节的byte数组 */ public static byte[] intTolhBytes4(int i) { byte[] result = new byte[4]; result[0] = (byte) (i &amp; 0xFF); result[1] = (byte) ((i &gt;&gt; 8) &amp; 0xFF); result[2] = (byte) ((i &gt;&gt; 16) &amp; 0xFF); result[3] = (byte) ((i &gt;&gt; 24) &amp; 0xFF); return result; } /** * 从byte数组的指定位置向后取出4位转为int数值，低位在前，高位在后 * * @param bs 原始数组 * * @param startSet 开始位 * * @return */ public static int hlBytesToInt(byte[] bs, int startSet) { int result; result = (int) ((bs[startSet] &amp; 0xFF) | ((bs[startSet + 1] &amp; 0xFF) &lt;&lt; 8) | ((bs[startSet + 2] &amp; 0xFF) &lt;&lt; 16) | ((bs[startSet + 3] &amp; 0xFF) &lt;&lt; 24)); return result; } /** * 从byte数组的指定位置向后取出4位转为int数值，高位在前，低位在后 * * @param bs 原始数组 * * @param startSet 开始位 * * @return */ public static int bytesToInt2(byte[] bs, int startSet) { int result; result = (int) (((bs[startSet] &amp; 0xFF) &lt;&lt; 24) | ((bs[startSet + 1] &amp; 0xFF) &lt;&lt; 16) | ((bs[startSet + 2] &amp; 0xFF) &lt;&lt; 8) | (bs[startSet + 3] &amp; 0xFF)); return result; } /** * long型转换为8字节的byte数组 高位在前低位在后 * * @param l long数据 * * @return */ public static byte[] longToHlBytes8(long l) { byte[] result = new byte[8]; for (int i = 0; i &lt; 8; i++) { int startSet = (result.length - 1 - i) * 8; result[i] = (byte) ((l &gt;&gt;&gt; startSet) &amp; 0xFF); } return result; } /** * short整数转换为2字节的byte数组 高位在前低位在后 * * @param s short整数 * * @return */ public static byte[] unsignedShortToByte2(int s) { byte[] result = new byte[2]; result[0] = (byte) (s &gt;&gt; 8 &amp; 0xFF); result[1] = (byte) (s &amp; 0xFF); return result; } /** * byte数组转换为无符号short整数 * * @param bs byte数组 * * @return */ public static int byte2ToUnsignedShort(byte[] bs) { return byte2ToUnsignedShort(bs, 0); } /** * byte数组转换为无符号short整数 * * @param bs byte数组 * * @param startSer 开始位置 * * @return */ public static int byte2ToUnsignedShort(byte[] bs, int startSer) { int high = bs[startSer]; int low = bs[startSer + 1]; return (high &lt;&lt; 8 &amp; 0xFF00) | (low &amp; 0xFF); } /** * byte数组转换为int整数 * * @param bs byte数组 * * @param startSet 开始位置 * * @return int整数 */ public static int byte4ToInt(byte[] bs, int startSet) { int b0 = bs[startSet] &amp; 0xFF; int b1 = bs[startSet + 1] &amp; 0xFF; int b2 = bs[startSet + 2] &amp; 0xFF; int b3 = bs[startSet + 3] &amp; 0xFF; return (b0 &lt;&lt; 24) | (b1 &lt;&lt; 16) | (b2 &lt;&lt; 8) | b3; }","link":"/2016/03/09/Byte-Common-transition/"},{"title":"贪婪算法","text":"贪婪算法贪婪算法(Greedy Algorithm)也叫算贪心法,贪婪法.它是一个遵循启发式解决问题的算法范式.它的核心思想就是通过在每一步的选择中都选用当前步骤下最优的选择,期望结果是最优的算法.如 旅行推销员问题. 贪婪算法尤其适用于有最优子结构的问题中,最优子结构的意思是局部的最优解可以导出全局的最优解.贪婪算法与动态规划 的不同在于贪婪算法对每一个子问题都作出选择,不能回退;动态规划则会保存以前的运算结果,根据以前的结果对当前进行选择,可以回退. 贪婪算法可以解决一些最优化(如最大值最小值等)问题,比如求图中的最小生成树、求哈夫曼编码…其他大多数的情况都不适用贪婪算法,一旦一个问题可以使用贪婪算法来解决,那么贪婪算法一般是解决这个问题的最好办法.由于贪婪算法的高效性以及其答案比较接近最有结果,也可以作为辅助算法或直接解决一些结果要求不那么精确的问题. 原理步骤 建立数学模型来描述问题,并建立一个备选答案区 把求解的问题分成若干个子问题, 使用一个选择函数对每个子问题求解最优解,并判断是否可用于整体问题 把所有子问题的最优解合成一个整的解 适用情况贪婪算法适用于一些数学问题等,大部分适用的问题都有两个特点: Greedy choice property (贪婪选择的属性)我们可以在每个子问题找出最好的选择然后进行总结.贪婪算法可能会根据迄今为止已经做的选择进行计算,但是却不会考虑之后子问题的选择.它将一个大的问题分解成小的问题并一个一个进行迭代计算.换句话说,贪婪算法不会重新考虑它已经得出的选择.这是它和 dynamic programming 的主要区别,动态规划会详尽的计算并确保得到最优解,在一步之后,动态规划会根据之前所有得到的选择进行下一个选择,并可能会重新对之前步骤的算法路径进行修改. Optimal substructure (最优子结构)这个问题要包含optimal substructure(即这个问题的最优解包含了它的子问题的最优解) 如以下几种类型的问题 Matroids (拟阵)matroid(拟阵) 是一个数学上的结构,它将linear independence (线性无关)的概念从 vector spaces (向量空间)推广到了任意的集合.如果一个最优解问题有一个拟阵结构,那么贪婪算法是最佳的解决办法. (子模块函数)一个函数 $f$ 定义了当集合 $\\Omega$ 的所有子集合 $S,T \\subseteq \\Omega$ 都满足 $f(S)+f(T)\\geq f(S\\cup T)+f(S\\cap T)$ 的情况即为子模块. 假设有人想要找到一个集合 $S$ 使得函数 $f$ 最大.贪婪算法将会通过逐个添加在每一步中使得 $f$ 增加最多的元素,产生一个结果至少是 $(1-1/e)\\max _{X\\subseteq \\Omega }f(X)$ ??todo. 所以,贪婪算法至少得出最优解的 $(1-1/e) \\approx 0.63$倍的解. 其他一些相对可以使用的问题 Set cover The Steiner tree problem Load balancing)[9] Independent set#Approximation_algorithms) 这些问题也可以使用贪婪算法,但不是最好的解法,他们在最差的情况下,可能会得到很差的结果. 失败的情况在很多其他问题上,贪婪算法无法产生最优解,甚至可能产生一个最坏的解决方案.比如之前提到的 traveling salesman problem :对每一个城市都要计算一个最近的邻居,这种方式可能会产生一个最坏的路程. 比如下图,贪婪算法只考虑到下一步的最优解,但是却没有考虑到之后的解决方案,导致实际上得出的不是一个最优解. Application贪婪法基本上（但并不是一定）不适用于求全局最优解，因为他通常没有遍历所有的数据。他们太早给出了肯定的选择使得他们无法从所有的解法中找到最优解。比如，使用 greedy coloring 算法来解决 graph coloring problem 以及所有的 NP-complete 问题。尽管如此，贪婪法还是很有用的，因为他们容易被考虑到并且通常情况下会给出一个比较好的解法。 如果一个贪婪算法可以被证明是某个问题的全局最优解法，他通常情况下就会成为优先选择的方法，因为它比其他的最优解方法如 dynamic programming 要快。这种例子有使用 Kruskal’s algorithm 和 Prim’s algorithm 找到minimum spanning trees,还有找到最优 Huffman trees. 贪心法也使用于 网络 路由 中。使用贪心路由，消息会被发送到距离目标节点“最近”的相邻节点。一个节点位置的定义（还有“最近”的含义）也许会取决于它的物理位置，如同在 ad hoc networks 中使用 geographic routing . 位置也可能会使一个人造的结构如同在 small world routing 和 distributed hash table 中. Referencehttps://en.wikipedia.org/wiki/Greedy_algorithm About Me我的博客 leonchen1024.com 我的 GitHub https://github.com/LeonChen1024 微信公众号","link":"/2018/12/03/Greedy-Algorithm/"},{"title":"实现键值对存储 第五部分 Hash table 实现","text":"实现键值对存储-第五部分: Hash table 实现原文链接 这篇文章是 IKVS 系列的第五部分,”实现一个键值对存储”.你也可以查看 Table of Contents 来查看其他部分. 在这篇文章中,我将会学习C++中实际的 hash table 来理解它的瓶颈在哪里.Hash 函数是 CPU-密集型的操作应该要进行优化.然而,大多数的 hash table 的机制都只是关注于高效的内存和I/O读取,这也是这篇文章主要的焦点.我将会学习三种不同的 C++中的hash table 的实现,同时包含内存中的和硬盘中的,并且会观察这些数据都是怎么组织和访问的.这篇文章将会包含以下内容. [TOC] 1. Hash tables1.1 对 hash tables 的一个快速介绍 Hashtable 按理说是一个对人类来说最重要的数据结构. — Steve Yegge 一个hash table 允许高效的访问关联数据.每一个条目都是一个键值对,只需要知道它的key就可以快速的检索或者分配.为了实现这个效果,key是使用hash函数来计算的,达到将这个key从它原始的表达转换为一个整数.然后使用这个整数作为索引来识别在存储条目值的数组中哪个位置是被访问的.很多key可以被hash到一个相同的值里,这意味着这些key会在这个数组位置碰撞.为了解决冲突问题,有很多中技术可以使用,比如在这个桶里使用 链表 或者 自平衡树等,或者使用 线性探查或者二次探查的开放式寻址. 从现在开始,我会假设你知道hash table 是什么.如果你觉得你需要复习一下相关知识,有一些好的资源是 Wikipidia[1] 上的 “Hash table” 这篇文章(还有页面底部的那些链接部分),还有就是 Cormen et. al [2] 的”Introduction to Algorithms” 这本书中的 Hash table 这个章节. 1.2 Hash 函数hash 函数的选择是特别重要的.一个好的 hash 函数最基础的要求就是输出的hash 值应该要分布均匀.这样,发生碰撞的概率就最小化了,同时也缩小了bucket 中碰撞的条目的数量. 这里有很多可以用的hash函数,并且除非你准确的知道这些存储的数据会是什么,否则最安全的做法是使用一个平均情况下分配随机数据最均匀的那个,如果可以的话要适用于”雪崩效应”[3]的情况.有一部分人已经在对比hash函数的效率了 [4] [5] [6] [7],从他们的结论得知,MurmurHash3 [8] 和 CityHash [9] 在这篇文章写完的时候是最好的hash函数. 2. 实现如同对比 hash 函数一样,现在也已经有一些博客和文章已经对比了 使用内存的 C++ hash table 库.我看过最值得注意的是 Nick Welch的 “Hash Table Benchmarks” [10] 和 Jeff Preshing 的 “Hash Table Performance Tests” [11], 但是还是有一些其他的文章也值得一看 [12] [13] [14]. 通过这些对比,我从 GCC 中的 TR1 派生出了 unordered_map 同时从 SparseHash 库中派生了 dense_hash_map — 之前被叫做 Google SparseHash —这是两个很值得学习的模块,并且下面我也会介绍到.此外,我还会介绍 Kyoto Cabinet 中的 HashDB 里的数据结构.当然 unordered_map 和 dense_hash_map 不会像 HashDB 那样和我的 key-value 存储项目关联性那么大,因为它们是内存内的 hash table . 虽然这样,对它们的内部数据结构的组织和它们的内存模式做一个简单的了解也是很有趣的. 对于这三个 hash table 库的介绍,我将会使用一个通用的例子,将一组城市的名字作为key,将它们的 GPS 坐标作为 value . unordered_map 的源码可以在 GCC 的源码中找到,它是在 libstdc++-v3 中. 我介绍的是基于 GCC v4.8.0中的 libstdc++-v3 release 6.0.18 [15],以及 SparseHash v2.0.2 [16] 中的 dense_hash_map , 还有 Kyoto Cabinet v1.2.76 [17] 中的 HashDB. 在 Matthew Austern 写的 “A Proposal to Add Hash Tables to the Standard Library (revision 4)” [18] 还有 SparseHash 中的 “Implementation notes” 页面 [19] 中也可以找到关于实现的有意思的讨论. 2.1 TR1 的 unordered_mapTR1 中的 unordered_map 提供了一个使用链表(单独链路)方式处理碰撞的问题的 hash table . 数组的位置分配是在堆上的,并且根据负载因子来进行扩大或者缩小.一个叫做 _Hash_node 的节点结构是用来创建桶的链表. 1234567/* from gcc-4.8.0/libstdc++-v3/include/tr1/hashtable_policy.h */ template struct _Hash_node&lt;_Value, false&gt; { _Value _M_v; _Hash_node* _M_next; }; 如果 key 和 value 都是整数类型的,它们可以被直接存储到这个结构的 _M_v 里.否则指针将会被使用并且需要一些额外的内存.桶数组在堆上就会被分配,但这并不影响 节点,它们使用的是 C++ 内存分配器中独立的调用: 12345678910111213141516/* from gcc-4.8.0/libstdc++-v3/include/tr1/hashtable.h */ Node* _M_allocate_node(const value_type&amp; __v) { _Node* __n = _M_node_allocator.allocate(1); __try { _M_get_Value_allocator().construct(&amp;__n-&gt;_M_v, __v); __n-&gt;_M_next = 0; return __n; } __catch(...) { _M_node_allocator.deallocate(__n, 1); __throw_exception_again; } } 因为节点是独立分配的,每个节点的分配可能会造成大量的内存浪费.这当然也取决于编译器和使用的操作系统的内存分配器.而且我甚至不讨论每种分配器的所有的系统调用.最原始的 SGI hash table 的实现会对节点进行资源预分配,但是这种策略在 TR1 的 unordered_map 实现中没有被保留. 下面的 图 5.1 提供了一个对于 TR1 的 unordered_map 的内存和访问模式.让我们来看看当我们根据key “johannesburg” 来查找关联的 GPS 坐标的时候会发生什么事.这个key 将会被 hash 然后映射到 bucket #0 .从那里我们跳转到这个bucket 对应的链表的第一个节点(bucket #0 左边橙色的箭头),并且我们可以访问堆里持有key “johannesburg” 数据的内存区域(Node 右边黑色的箭头).如果key 在第一个节点是无效的,我们可以指向到其他的节点. 至于CPU 的性能,人们不能指望将所有的数据都放在处理器同一个缓存行里.的确,给定了 bucket 数组的大小,初始化的 bucket 和初始化的节点将不会在同一个缓存行里,并且节点关联的额外的数据也不会在同一个缓存行中.子序列节点和关联的数据也不会在相同的缓存行里并且必须从 RAM 中检索.如果你并不熟悉CPU 优化和缓存行, 这篇 Wikipedia 上的 “CPU Cache” 文章将会是一个很好的介绍 [20]. 2.2 SparseHash 的 dense_hash_mapSparseHash 库提供了两种 hash table 的实现, sparse_hash_map 和 dense_hash_map. sparse_hash_map 通过降低了速度提供了惊人的内存占用,并且使用制定的数据结构来获取结果,这就是 sparsetable. 想要了解更多的关于 sparsetables 和 sparse_hash_map 的信息可以去SparseHash 的 “Implementation notes” 页 [19].在这里我只会介绍 dense_hash_map. dense_hash_map 使用二次内部探查处理碰撞问题.如同 unordered_map ,bucket 数组在一开始就在堆里分配了,并且会根据 hash table 的负载因子进行放大或者缩小. bucket 数组的元素是 std::pair 的实例,其中 Key 和 T 分别是 键和值的模板参数.在一个 64-位体系架构中保存字符串, 每一对的实例将会占用 16字节. 下图 5.2 提供了一个对于 dense_hash_map 的内存和访问模式的示意图.如果我们查找 “johannesburg” 的 GPS 坐标,我们一开始会在 bucket #0 中查找失败,因为它的数据是 “Paris” 的(bucket #0 右边的黑色箭头).所以我们会继续探查并跳转到 bucket (i + 1) = (0 + 1) = 1 (bucket #0 左边橙色的箭头),然后我们会在 bucket #1 中查找 “johannesburg” 对应的数据(bucket #1 右边黑色的箭头).这看起来和 unordered_map 很相似,但实际上是非常不同的.当然,就像 unordered_map 一样键和值将会被存储在堆内存中,这意味着键和值的查找将无法使用缓存行.但是bucket 中的碰撞条目的导航将会变得非常快.的确,在大多数的处理器中缓存行是 64byte , 而我们指定每一对占用16byte的容量,这将会显著的提高我们的速度,和 unordered_map 中的链表相反,它需要在RAM中跳转来得到接下去的节点. 通过二次内部探查提供的缓存行优化使得 dense_hash_map 在 使用内存的 hash table 中的性能测试成为胜利者(至少是我了解的那些).你应该花点时间看一看 Nick Welch 写的 “Hash Table Benchmarks” [10]. 2.3 Kyoto Cabinet 的 HashDBKyoto Cabinet 实现了许多的数据结构,其中也包括 hash table . 比如这个 hash table , HashDB ,是用来在硬盘上持久化的,尽管这里有一个可选方案可以将他作为 std::map 的替代品. hash table 的元数据还有用户数据都是通过文件系统按顺序保存在唯一的一个硬盘文件中. Kyoto Cabinet 通过在每一个 bucket 上使用独立的二分查找树来处理碰撞问题.bucket 数组有一个固定的大小并且永远不会调整大小,不管负载因子的状态是什么.这是它主要的缺陷.确实,如果在数据库的创建的时候定义的 bucket 数组的大小比实际的需求要小的花,那么当条目开始碰撞的时候性能将会变得很差. 对于一个使用 硬盘的 hash table 实现来说,要让 bucket 数组的大小可以调整是非常困难的.首先,这会要求 bucket 数组还有条目要存储在两个独立的文件里.这样子它们就可以分别增长了.第二,因为需要重新调整 bucket 数组的大小所以需要重新对 key 进行hash操作来对应到它们在新的bucket 数组中位置,这会需要从硬盘中读取所有的条目对应的key,这会非常的消耗性能或者可以说在数量大的数据库情况下来说是不可能的.一个可以避免重新hash的方法是存储 hash 后的key,但是这意味着每一个条目都需要额外 4 或 8 byte 的数据(根据 hash 是 32 还是 64 bit 长的).因为这些种种的复杂性,使用一个定长的 bucket 数组是更简单的,并且这也是 Kyoto Cabinet 中的 HashDB 采用的方法. 图 5.3 展示了存储在文件中的 HashDB 的结构.我从 clac_meta() 方法还有 kchashdb.h 文件底部中的 HashDB 类的代码属性的注释中中派生了这个内部结构.这个文件由以下的部分构成: 数据库所有元数据的头部. FreeBlock pool 用来持有数据区域中的可用空间 bucket 数组 记录(数据区域) 一条记录会持有一个条目(键/值对),使用了一个单独连接的二叉搜索树的节点.下面是 Record 的结构: 1234567891011121314151617/* from kyotocabinet-1.2.76/kchashdb.h */ /** * Record data. */ struct Record { int64_t off; ///&lt; offset size_t rsiz; ///&lt; whole size size_t psiz; ///&lt; size of the padding size_t ksiz; ///&lt; size of the key size_t vsiz; ///&lt; size of the value int64_t left; ///&lt; address of the left child record int64_t right; ///&lt; address of the right child record const char* kbuf; ///&lt; pointer to the key const char* vbuf; ///&lt; pointer to the value int64_t boff; ///&lt; offset of the body char* bbuf; ///&lt; buffer of the body }; 观察图 5.4 可以知道硬盘上的记录的组织.我从 kchashdb.h 中的 write_record() 方法中派生了这个结构. 注意它和 Record 的结构是不一样的: 使用硬盘的方式的目标是要最小化占用的空间,同时这个结构的目的还要让它在程序上能够便于使用.所有在 图 5.4 中的字段都是固定长度的,除了 key ,value ,还有 padding ,这些数据当然是根据条目里的数据大小来决定的. left 还有 right 字段是这个二叉搜索树节点的一部分,并在文件中保存了其他记录的偏移量. ​ Figure 5.3 ​ Figure 5.4 如果我们想要访问key “Paris” 的值,我们将会从获取关联 bucket 初始记录的偏移开始,也就是 bucket #0.接下来我们会跳转到这个bucket 的二叉搜索树的头节点(bucket #0 左边的橙色的箭头),它持有了key “Johannesburg” 的数据. key “Paris” 的数据可以通过这个节点的右子节点来访问(“Johannesburg” 记录右边的黑色箭头).二分查找树需要一个 “可对比” 类型以此来对节点进行分类.这里使用的可以对比的类型是将hash 后的key 通过 fold_hash() 方法简化成一个更小的表示. 123456/* from kyotocabinet-1.2.76/kchashdb.h */ uint32_t fold_hash(uint64_t hash) { _assert_(true); return (((hash &amp; 0xffff000000000000ULL) &gt;&gt; 48) | ((hash &amp; 0x0000ffff00000000ULL) &gt;&gt; 16)) ^ (((hash &amp; 0x000000000000ffffULL) &lt;&lt; 16) | ((hash &amp; 0x00000000ffff0000ULL) &gt;&gt; 16));} 将条目和节点存储在一个记录中在一开始可能会看起来像一个设计错误,但是实际上是非常聪明的.为了存储一个条目的数据,通常需要管理3个不同的数据:bucket , 碰撞 ,还有条目.在给定的 bucket 数组中的bucket 必须按照定义顺序存储,它们只能这么存储并且没有什么可以提升的地方.然后假设我们不存储整数类型而是存储字符串或者可变长 byte 的数组之类的无法被存储在 bucket 自身的东西,另一个内存访问将会需要存储到 bucket 数组之外的区域.因此,在添加新的条目的时候,需要存储碰撞的数据结构和条目的键值. 如果碰撞数据和条目数据是独立存储的,除了需要访问bucket 之外,还需要访问两次硬盘,如果是设置值的情况,这会导致在硬盘上写入3次,可能还是在相隔很远的地方.这意味着磁盘上的随机写入模式,这对于I/O而言是最糟糕的事.现在因为 Kyoto Cabinet 的 HashDB 节点数据和条目数据被存储在了一起,它们可以仅通过一次写入磁盘而不用两次.的确,bucket 还是需要被访问的,但是如果 bucket 数组足够小,它将会被操作系统从磁盘中缓存到 RAM 中,这是 Kyoto Cabinet 最主要的假设,正如 specs 中 “Effective Implementation of Hash Database” 这一章节描述的那样[17]. 然而这里还有一个需要关心的是将二分查找树节点和条目一起保存到磁盘上,这会降低读取的速度,至少是在碰撞开始发生的时候.的确,因为节点和条目存储在了一起,要解决 bucket 中的碰撞就意味着要找到记录中持有有效条目的二分查找树,这会需要在磁盘上进行许多随机的读取.这样就可以更好的理解为什么 Kyoto Cabinet 在条目的数量超过 bucket 的时候会出现这样的性能下降的原因. 最后,因为所有的东西都被存储在一个文件中,内存管理都是由 Kyoto Cabinet 自己来处理的,并不是像 unordered_map 还有 dense_hash_map 那样交给操作系统来管理.FreeBlock 结构持有了关于文件中空闲空间的信息,基本上是有关与偏移和大小,可以看下面的介绍: 123456789101112131415/* from kyotocabinet-1.2.76/kchashdb.h */ /** * Free block data. */ struct FreeBlock { int64_t off; ///&lt; offset size_t rsiz; ///&lt; record size /** comparing operator */ bool operator &lt;(const FreeBlock&amp; obj) const { _assert_(true); if (rsiz &lt; obj.rsiz) return true; if (rsiz == obj.rsiz &amp;&amp; off &gt; obj.off) return true; return false; } }; 所有的 FreeBlock 实例都是在 std::set 中加载的,允许使用 std::set 中的 upper_bound() 方法来检索空闲内存块,就像 fetch_free_block() 方法中那样,调整一个”最适合” 的内存分配策略.当空闲内存块的分布太过碎片化或者在 FreeBlock 池中没有剩余的空间的时候,文件会进行碎片整理.这个碎片整理的过程会移动记录来减小 数据库文件的大小. 3. 结论在这篇文章中,我介绍了三种不同的 hash table 库的数据组织和内存访问模式. TR1 中的 unordered_map 和 SparseHash 中的 dense_hash_map 是在内存中的, Kyoto Cabinet 中的 HashDB 是在磁盘上的.这三个实现使用了不同的方式来处理碰撞问题,在性能上也有不同的表现.分离 bucket 数据,碰撞数据还有条目数据将会影响性能,这就是 unordered_map 使用的方法.通过将碰撞数据和bucket 存储到一起可以有效的提高速度,就像dense_hash_map 使用的方式 二次内部探查, 或者像 HashDB 使用的方式一样.这些方案都可以提高写入的速度,但是将碰撞数据和bucket 存储到一起还会提高读取速度. 还有一件事是我从学习这些哈希表的库的时候明白的,当设计一个哈希表的数据结构的时候,应该优先考虑将碰撞数据和bucket 数据保存在一起,而不是和条目保存在一起.这是因为就算哈希表是在磁盘上的,bucket 数组和碰撞数据也会小到可以存储在RAM中,这样子随机读取会比在磁盘上的消耗少很多. 4. References[1] http://en.wikipedia.org/wiki/Hash_table[2] http://www.amazon.com/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844/[3] http://en.wikipedia.org/wiki/Avalanche_effect[4] http://blog.reverberate.org/2012/01/state-of-hash-functions-2012.html[5] http://www.strchr.com/hash_functions[6] http://programmers.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed/145633#145633[7] http://blog.aggregateknowledge.com/2012/02/02/choosing-a-good-hash-function-part-3/[8] https://sites.google.com/site/murmurhash/[9] http://google-opensource.blogspot.fr/2011/04/introducing-cityhash.html[10] http://incise.org/hash-table-benchmarks.html[11] http://preshing.com/20110603/hash-table-performance-tests[12] http://attractivechaos.wordpress.com/2008/08/28/comparison-of-hash-table-libraries/[13] http://attractivechaos.wordpress.com/2008/10/07/another-look-at-my-old-benchmark/[14] http://blog.aggregateknowledge.com/2011/11/27/big-memory-part-3-5-google-sparsehash/[15] http://gcc.gnu.org/[16] https://code.google.com/p/sparsehash/[17] http://fallabs.com/kyotocabinet/spex.html[18] http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1456.html[19] http://sparsehash.googlecode.com/svn/trunk/doc/implementation.html[20] http://en.wikipedia.org/wiki/CPU_cache About Me我的博客 leonchen1024.com 我的 GitHub https://github.com/LeonChen1024 微信公众号","link":"/2019/04/09/Key-Value-pair-in-hashtable/"},{"title":"LRU 缓存的魔力","text":"LRU 缓存的魔力场景假设这么一个情况,当你需要多次展示同一个图片的时候,如果你重复从硬盘中加载图片的话,那么会造成资源的浪费,甚至可能会OOM. 这个时候我们可以使用 cache 来避免这种情况,我们只从硬盘中加载一次到内存中,然后在需要的时候反复使用这个照片. 但是,当这个 cache 里的资源已经装满的时候,那么我们就必须移除cache里面的某些数据,来给要加入的数据腾出空间. 解决方案在这种情况下,我们应该选择移除哪些资源才是最有优的呢?显而易见的,我们应该移除之后不会用到的资源,还有就是间隔最久才会用到的资源.这里有一个详细的最优算法如下:$$T = m * T_m + T_h + E$$其中: T = 平均内存引用时间 m = 没选中的概率 = 1 - (选中的概率) T_m = 当没选中的时候主内存访问的时间(或者,如果是多级缓存的时候,还要算上更低级的缓存内存引用时间的平均值) T_h = 延迟 : 当选中该资源的时候缓存引用的时间 E = 各种副作用,比如多处理器系统中的 排队效应 LRU要得到一个完美的方法是很复杂的,这里我们介绍一个常用的算法,叫做 LRU cache (least recently used),它的原理很简单,就是把使用的元素提到队列的开始,这样最近使用的资源将会在开始的地方,而那些长期未被使用的资源将会在后面,然后当空间不够的时候将会从后面开始释放资源.LRU 的思路是最近使用的资源他们就推测他在未来也有更大的可能性会被使用. LRU 并不是一个普通的容器.他需要一些策略来实现他的要求. LruCache 由键值对组成 , 形如 LruCache 它需要有一个最大值,要注意它的取值,太小的话那么缓存不了多少东西,会导致频繁的重新读取,导致失去缓存的意义,太大的话可能会导致 oom.所以最好是根据你的应用当前可用的内存来决定这个大小. 1234567//set the max memory used by lruActivityManager am = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);int availMemInBytes = am.getMemoryClass() * 1024 * 1024;//8 is a common value , we can twist it by how much memory can we app used,//and what kind of the phone we run on.LruCache bitmapCache = new LruCache&lt;String,Bitmap&gt;(availMemInBytes / 8); 其中 8 是一个比较通用的值,当然你可以根据你的应用所占用的内存来进行调整,还有运行的机型的限制等. 我们还需要知道里面存储的每一个对象的值的大小.比如我们可以 12345678Public class ThumbnailCache extends LruCache&lt;String,Bitmap&gt;{ @Override protected int sizeOf(String key,Bitmap value){ //return the size of the in-memory bitmap, //counted against maxSizeBytes return value.getByteCount(); }} 当我们从 LruCache 中获取数据的时候,需要对数据已经被回收或者没有进入过缓存的情况做处理. 1234567// get data from Lru and put data to LruBitmap bmpToDraw = mCache.get(filename);if(bmpToDraw == null){ bmpToDraw = BitmapFactory.decodeFile(filename); mCache.put(filename,bmpToDraw);} 还要注意的一点是,当你存进一个较大的对象的时候,有时候 LruCache 会同时清理多个资源来给这个对象腾出位置. Resourcehttps://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE About Me我的博客 leonchen1024.com 我的 GitHub https://github.com/LeonChen1024 微信公众号","link":"/2018/12/23/S1ep1-The-macgic-of-LRU-Cache/"},{"title":"Serializable","text":"Serializable通过实现 java.io.Serializable 可以让 class 实现序列化的功能，否则无法使用序列化的功能。一个实现序列化的类的子类都是可以进行序列化的。Serializable 接口没有方法，字段等只是一个标记它是可以序列化的作用。 序列化是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或在网络中传送），并在需要的时候恢复原先状态的过程。 当子类实现了 Serializable 接口而父类没有实现的时候，父类要有一个可以访问的无参构造函数。 在反序列化的时候，没有实现序列化的类字段将会使用 public 或者 protect 的无参构造函数进行初始化。无参构造函数必须是实现序列化的子类可访问的， 如果需要在序列化和反序列化的时候进行一些特殊操作的话，需要自己实现以下某些方法： 123456private void writeObject(java.io.ObjectOutputStream out) throws IOExceptionprivate void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;private void readObjectNoData() throws ObjectStreamException; writeObject 方法负责写入指定的类的对象状态来让 readObject 方法可以读取这些状态。可以通过调用 out.defaultWriteObject 方法来使用默认的保存对象字段的机制。 readObject 方法负责从流中读取并回复类字段。它可能会调用 in.defaultReadObject 方法来默认恢复非静态和非临时(transient)的字段机制。defaultReadObject 方法使用流中的信息来分配流中保存的对象字段到目前的对象相应名字的字段中。这解决了当类已经添加了新的字段时的问题。 这两个方法不需要考虑它自己的父类或者子类。状态是通过 writeObject 方法将各自的字段写入到 ObjectOutputStream 中，或者通过 DataOutput 提供的方法将私有的数据类型进行保存。 readObjectNoData 方法负责在当序列化流没有列出指定的类作为反序列化的对象的父类的时候初始化对象的状态。这可能会发生在接收部分使用了一个和发送部分不同版本的反序列化实例的类的时候，还有接收的版本继承的类不是发送版本继承的类的时候。还可能发生在序列化流发生错误的时候。因此，readObjectNoData 方法在”恶意”的或者不完整的流情况下初始化反序列化对象属性是非常有用的。 Serializable 类需要在写入一个对象到流的时候指定一个替换的对象的话需要用指定的修饰符实现这个方法 1ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException; 这个 writeReplace 方法如果存在并且它可以被被序列化的对象中定义的方法调用的话，writeReplace 会在序列化的时候被调用。因此，这个方法可以使用 private , protected 或者 package-private修饰。子类的访问权限遵循 Java 的访问规则。 如果类的实例从流中读取出来的时候需要指定一个替换的类的话应该使用明确的修饰符实现这个方法。 1ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException; readResolve 方法的调用规则和访问规则和 writeReplace 相同。 序列化在运行时会关联每一个可以序列化的类的版本数字，名为 serialVersionUID ， 这个 serialVersionUID 会在反序列化的时候使用，主要作用是验证一个序列化对象的发送方和接收方加载的类是兼容的。如果接收方给对象加载的类的 serialVersionUID 和对应的 发送方的类的 serialVersionUID 不同的话，反序列化的时候会导致一个 InvalidClassException . 可序列化的类可以通过定义一个静态 final long 字段名为 “serialVersionUID” 声明它自己的 serialVersionUID : 1ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L; 如果可序列化的类没有明确的定义一个 serialVersionUID ，那么运行时序列化将会如Java(TM)对象序列化规范所描述的那样依据类的多个方面计算出一个默认的 serialVersionUID 值。尽管如此，官方还是强烈推荐所有的可序列化类明确的定义 serialVersionUID 值，因为默认的 serialVersionUID 计算对类的细节是高度敏感的，会依据编译器的实现而变动，可能会在反序列化时导致预期之外的 InvalidClassException 异常。因此，为了确保在不同的 Java 编译器实现中保持 serialVersionUID 不变，可序列化的类必须明确定义一个 serialVersionUID 值。官方还强烈推荐尽可能使用 private 来修饰 serialVersionUID 定义，因为这样的声明只适用于当前的类，而不会影响那些继承他的类。Array 类不能显式的声明 serialVersionUID ，所以它们总是使用默认计算的值，但是 Array 类不需要比对 serialVersionUID 。 Android 实现的 serialVersionUID 计算方式在 Android N 上会有一些轻微的不同。为了保持兼容性，这个改变只有在应用的目标 SDK 版本设置为 24 或者更高的时候才会可用。强烈推荐使用显式的 serialVersionUID 字段来避免兼容性问题。 谨慎的实现 Serializable参考 《Effective Java》中对于序列化 API 覆盖的章节。书中介绍了如何在不影响应用程序的可维护性的前提下使用这个接口。 推荐另一个可行的方法JSON 是一种简明，可读性高并且高效的方式。Android 包含了 android.util.JsonReader 流 API 和 org.json.JSONObject 树 API 来对 JSON 进行读写。也可以使用绑定库比如 GSON 来更直接的读写 Java 对象。 Referencehttps://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html About Me我的博客 leonchen1024.com 我的 GitHub https://github.com/LeonChen1024 微信公众号","link":"/2019/01/02/Serializable/"},{"title":"LeetCode 1 Two Sum [English ver]","text":"[English ver]1 Two SumQuestionTwo SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. First time, i got a wrong try.1234567891011121314151617181920public class Solution { public int[] twoSum(int[] nums, int target) { int[] testNums = new int[nums.length]; int j = 0; for (int i=0;i&lt;nums.length;i++){ if(nums[i]&lt;target){ testNums[j] = nums[i]; j=j+1; } } for(int l=0;l&lt;j;l++){ for(int k=l+1;k&lt;j;k++){ if(testNums[l]+testNums[k]==target){ return new int[]{l,k}; } } } return null; }} I did not understand the meaning of problem , the last we get by this solution are the index of the array which we created , rather than the requirements of the index of he gave , fainted. . . Later i had found a more serious problem. . The problem did not say there can not be negative number ! . . . It is not necessary to determine whether the value of the array is bigger than the target number. . . And then i re-think about it, the first solution is a basic way. Approach 1：Brute Force123456789101112public class Solution { public int[] twoSum(int[] nums, int target) { for (int i=0;i&lt;nums.length;i++){ for(int k=i+1;k&lt;nums.length;k++){ if(nums[i]+nums[k]==target){ return new int[]{i,k}; } } } throw new IllegalArgumentException(&quot;No two sum solution&quot;); }} for the results,uh Well, the simplest solution often means the less efficient way. AnalysisThe principle of this method is very simple, Loop through each element x and find if there is another value that plus x and then equals to target . you have to attention to “K = i + 1” of “for(int k=i+1;k&lt;nums.length;k++)” is in order to avoid the previous looped of the situation looped again. Time complexity: O (n ^ 2). For each element, we try to find its complement by looping through the rest of array which takes O(n). so it is n ^ 2.Space complexity: O (1). Approach 2 Two-pass Hash Table123456789101112131415public class Solution { public int[] twoSum(int[] numbers, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; numbers.length; i++) { map.put(numbers[i],i); } for (int i = 0; i &lt; numbers.length; i++) { int requestNum = target - numbers[i]; if (map.containsKey(requestNum)&amp;&amp;map.get(requestNum)!=i) { return new int[]{i,map.get(requestNum)}; } } throw new IllegalArgumentException(&quot;No two sum solution&quot;);}} You can see the efficiency has been greatly improved. AnalysisThe principle of this method is to use the hash table to replace the time cost of space costs, a complexity of O(n) change into near O(1) , why should i use “near”, because if the hash table has a lot Of collision occurredthe, it will lead to complexity to near O(n) . We use the value of each element in the array as a key into the hash table, and its index number as the key’s value into the hash table, and then traverse the array to find whether there is a corresponding value in the hash table key, if we find that, get the key’s value .Time complexity: O (n)Space complexity: O (n) Approach 3 One-pass Hash Table12345678910111213public class Solution { public int[] twoSum(int[] numbers, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; numbers.length; i++) { int requestNum = target - numbers[i]; if (map.containsKey(requestNum)) { return new int[]{map.get(requestNum),i}; } map.put(numbers[i],i); } throw new IllegalArgumentException(&quot;No two sum solution&quot;);}} The efficiency is slightly improved. But i can’t accept that how is it just in the middle efficiency of the whole approach. . . And then i tried several times, it is always in the about 40% to 50% position, these methods in front of this solution’s position how can they work?. . . Why so fast? Theoretically, it is necessary to loop the results at least once, that is, the complexity of O (n) is required. AnalysisThe principle of this method actually is an improvement of the method two, because we do not need to put all the arrays into the hash table, what we need is to get the sum of two number which equals to the number of the target number , so we check if current element’s complement already exists in the table when we put the array’s element into the hash table , once we find the required value we stop the loop.Time complexity: O (n)Space complexity: O (n) If you have a better method or have other opinions on the description of me here, please contact me. Thank you.","link":"/2017/02/17/1-Two-Sum/Record[English ver]/"},{"title":"LeetCode 2. Add Two Numbers [Chinese ver]","text":"[Chinese ver] 2. Add Two Numbers问题：你将获得两个非空 linked lists来表示两个非负整数。 数字以反向的顺序存储，并且它们的每个节点包含一位数字。 将两个数字相加并将其以 linked list的形式返回。 你可以假定这两个数字不包含任何前导零（即不存在首位出现0的情况），除了数字0本身。 输入 ：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出 ： 7 -&gt; 0 -&gt; 8 方法一：12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) { int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; } if (carry &gt; 0) { curr.next = new ListNode(carry); } return dummyHead.next;} 分析其实这个问题熟悉一下链表的使用和算术的逻辑就可以解决了。按位加过十进一，注意，加法的进位只会是0或者1，因为就算你用两个最大的数9+9最后也只是进一，进一之后再9+9+1也只会得到19，还是进一。所以主要的逻辑就是两个数的和sum/10得到的是进位，sum%10得到的是本位的数。dummyHead是一个假的数据头，用来做一个初始化，不使用也是可以的，但是在内部逻辑中就需要自己在处理第一位和后续的位数的逻辑区别。注意有几种特殊情况。1.其中一个list的长度比另一个要长。2.其中一个list为空。3.加到最后一位时仍然还有进位 时间复杂度： O(max(m,n)).总共循环m和n中的最大次数。空间复杂度 : O(max(m,n)).我们得到的新的list 的长度是m,n中最大长度，加上一个假数据头。 方法二12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */public class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode ln1 = l1, ln2 = l2, head = null, node = null; int carry = 0, remainder = 0, sum = 0; head = node = new ListNode(0); while(ln1 != null || ln2 != null || carry != 0) { sum = (ln1 != null ? ln1.val : 0) + (ln2 != null ? ln2.val : 0) + carry; carry = sum / 10; remainder = sum % 10; node = node.next = new ListNode(remainder); ln1 = (ln1 != null ? ln1.next : null); ln2 = (ln2 != null ? ln2.next : null); } return head.next; }} 这个是别人的做法，居然能够比方法一快了许多，说实话，其实这两个方法在整体思路上是差不多的，至于为什么会比前者快那么多我觉的是方法一在循环中不断新建了x,y等对象，由于计时时用了成千上百的例子验证所以导致了20ms左右的差距。以上纯属个人看法，如果你有更正确的想法，或者哪里有有关这种差距的论证，请告诉我。谢谢。 About Me我的博客 leonchen1024.com 我的 GitHub https://github.com/LeonChen1024 微信公众号","link":"/2018/07/15/2-Add-Two-Num/Record[Chinese-ver]/"},{"title":"LeetCode 1 Two Sum [Chinese ver]","text":"[Chinese ver]1 Two SumQuestion两数求和 。给定一个整数的数组，返回两个数字的索引使得这两个数字加起来成为一个指定的目标值。你可以假设每个输入都至少有一个解决方案，并且你不能使用相同的元素两次。 Example:123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 首先是一次错误的尝试1234567891011121314151617181920public class Solution { public int[] twoSum(int[] nums, int target) { int[] testNums = new int[nums.length]; int j = 0; for (int i=0;i&lt;nums.length;i++){ if(nums[i]&lt;target){ testNums[j] = nums[i]; j=j+1; } } for(int l=0;l&lt;j;l++){ for(int k=l+1;k&lt;j;k++){ if(testNums[l]+testNums[k]==target){ return new int[]{l,k}; } } } return null; }} 没理解好题意，这种解法最后得到的是我们自定义数组的序号，而不是题目要求的序号，晕倒。。。后来发现一个更严重的问题。。他没有说过不能有负数！！！！也就不需要判断数组里的值是否大于和。。。 然后重新构思一下，先来个基本的解法 方法一：暴力循环123456789101112public class Solution { public int[] twoSum(int[] nums, int target) { for (int i=0;i&lt;nums.length;i++){ for(int k=i+1;k&lt;nums.length;k++){ if(nums[i]+nums[k]==target){ return new int[]{i,k}; } } } throw new IllegalArgumentException(\"No two sum solution\"); }} 至于结果嘛，最简单的自然也高效不到哪里。 分析这个方法的原理很简单，就是将每一个值与其他的值循环遍历，看是否有符合条件的情况发生。稍微要注意的是 for(int k=i+1;k&lt;nums.length;k++) 这里k=i+1是为了避免前面循环过的情况再次循环一遍。时间复杂度 ： O(n^2) 。n个元素都要循环遍历数组内其余的元素，所以是n^2。空间复杂度 ： O(1) . 方法二：两次循环的 hash table123456789101112131415public class Solution { public int[] twoSum(int[] numbers, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; numbers.length; i++) { map.put(numbers[i],i); } for (int i = 0; i &lt; numbers.length; i++) { int requestNum = target - numbers[i]; if (map.containsKey(requestNum)&amp;&amp;map.get(requestNum)!=i) { return new int[]{i,map.get(requestNum)}; } } throw new IllegalArgumentException(\"No two sum solution\");}} 可以看到效率有了很大的提升。 分析这个方法的原理其实就是使用hash table 来将时间成本来替换空间成本，将一次复杂度为O(n)的循环变为接近O(1)的查找，为什么是接近呢，因为如果hash table发生大量的碰撞，就会导致复杂度向O(n)靠近。我们将数组里每一个元素的值作为key存入hash table，而将其序列号作为对应的value存入hash table，然后遍历数组查找是否有对应的值在hash table 的key中，有则取出该key对应的value。时间复杂度 ： O(n)空间复杂度 ： O(n) 方法三：一次循环的 hash table12345678910111213public class Solution { public int[] twoSum(int[] numbers, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; numbers.length; i++) { int requestNum = target - numbers[i]; if (map.containsKey(requestNum)) { return new int[]{map.get(requestNum),i}; } map.put(numbers[i],i); } throw new IllegalArgumentException(\"No two sum solution\");}} 效率稍微提高了一些。。但是有些不能接受啊。怎么还只是在中间的位置。。。然后试了几次，大概在40%到50%徘徊，前面那些是用什么算的。。。为何那么快。理论上来说至少需要循环比对结果一次，也就是需要O(n)的复杂度。 分析这个方法的原理其实就是方法二的一个改善，因为我们不需要将全部的数组都放入hash table ，我们最终的目的是为了得到两个相加等于目标数的值的序号即可，所以我们在将数组里的值放入hash table 的时候就进行比对，一旦得到所需要的值立即结束循环。时间复杂度 ： O(n)空间复杂度 ： O(n) 如果你有更好的办法或者对我这里的描述有其他看法，请联系我。谢谢","link":"/2017/02/17/1-Two-Sum/Record[Chinese ver]/"},{"title":"LeetCode 2. Add Two Numbers [English ver]","text":"[English ver] 2. Add Two NumbersQuestion ：You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Approach 1：12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) { int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; } if (carry &gt; 0) { curr.next = new ListNode(carry); } return dummyHead.next;} AnalysisActually, the problem is easy to resolved if you are familiar with the use of the list and the logic of the arithmetic . Plus every bit base on decimal, note that the addition of the carry will only be 0 or 1, because even if you use the two largest number 9 +9 in finally you only get carry 1, then use the largest number 9 +9 + 1 will only Get 19, the carry is 1 too. So the main logic is (the sum of two numbers )sum / 10 is the carry, sum% 10 is the number of the this bit . DummyHead is a fake data header, used to do an initialization, it is possible if you don’t want to use it, but in the internal logic you need to deal with the difference logic between the first bit of the result and the number of subsequent .Note that there are several special cases. 1. The length of one list is longer than the other. 2. One of the lists is empty. 3. There is still have a carry in the last bit Time complexity: O (max (m, n)). The total number of cycles is the largest number between m and n.Space complexity: O (max (m, n)). The length of the new list we create is the maximum length of m, n, plus a dummy header. Approach 212345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */public class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode ln1 = l1, ln2 = l2, head = null, node = null; int carry = 0, remainder = 0, sum = 0; head = node = new ListNode(0); while(ln1 != null || ln2 != null || carry != 0) { sum = (ln1 != null ? ln1.val : 0) + (ln2 != null ? ln2.val : 0) + carry; carry = sum / 10; remainder = sum % 10; node = node.next = new ListNode(remainder); ln1 = (ln1 != null ? ln1.next : null); ln2 = (ln2 != null ? ln2.next : null); } return head.next; }} This is someone else’s approach, actually these two methods in the overall thinking is almost the same ,but this approach is more faster than approach 1 . why ? I think the approach 1 is always create a int x,y and other objects in the cycle , because the timing was based on thousands of examples , result a gap about 20ms. This is purely personal think , if you have more correct ideas, or somewhere is an argument about the reason this gap, please tell me. Thank you. About MeMy blog leonchen1024.com My Github [https://github.com/LeonChen1024","link":"/2018/07/15/2-Add-Two-Num/Record[English-ver]/"},{"title":"LeetCode 4. Median of Two Sorted Arrays [Chinese ver]","text":"[Chinese ver] 4. Median of Two Sorted Arrays这里有两个有序数组nums1和nums2，他们各自的大小为m和n.找到这两个数组的中间值，总的时间复杂度应该为O(log (m+n)). 1234Example 1:nums1 = [1, 3]nums2 = [2] 中间值是 2.0 1234Example 2:nums1 = [1, 2]nums2 = [3, 4]中间值是 (2 + 3)/2 = 2.5 方法一：首先尝试了一种比较笨的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { //需要几个数值 int needNum = 0; //数值位置 int needIndex = 0; //中间值 double median = 0; int big = 0; int stand = 0; //合成的数组 int[] insertnum ; int m = nums1.length; int n = nums2.length; if((m+n)%2==0){ needNum = 2; needIndex = (m+n)/2-1; }else{ needNum=1; needIndex = (m+n)/2; } insertnum = new int[m+n]; //nums1的下标 int j =0; //nums2的下标 int k = 0; for(int i =0;i&lt;m+n;i++){ if(k==n){ insertnum[i] = nums1[j]; j++; } else if(j==m){ insertnum[i] = nums2[k]; k++; }else if(nums1[j]&gt;nums2[k]){ insertnum[i] = nums2[k]; k++; }else{ insertnum[i] = nums1[j]; j++; } } if(needNum == 1){ median = Double.valueOf(insertnum[needIndex]); }else{ median = Double.valueOf(insertnum[needIndex]+insertnum[needIndex+1]) /2.0; } return median; }} 顺便提一下，这个方法经常无法通过，应该是时间复杂度过高的原因吧。 分析这个方法的原理很简单，首先将两个数组个数和是奇数和偶数的情况所需的取值个数以及中间值计算方法得出。然后将两个数组按照从小到大的顺序合并成一个数组，最后根据前面得到的中间数的计算方法得出中间值。时间复杂度 ： O(m+n) 。空间复杂度 ： O(m+n) . 这个方法可以在做一个优化，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int needNum = 0; int needIndex = 0; double median = 0; int big = 0; int stand = 0; int[] insertnum ; int m = nums1.length; int n = nums2.length; if((m+n)%2==0){ needNum = 2; needIndex = (m+n)/2-1; }else{ needNum=1; needIndex = (m+n)/2; } insertnum = new int[(m+n)/2+1]; int j =0; int k = 0; for(int i =0;i&lt;m+n;i++){ if(k==n){ insertnum[i] = nums1[j]; j++; } else if(j==m){ insertnum[i] = nums2[k]; k++; }else if(nums1[j]&gt;nums2[k]){ insertnum[i] = nums2[k]; k++; }else{ insertnum[i] = nums1[j]; j++; } if (i &gt;= needIndex ){ if (needNum == 1){ median = Double.valueOf(insertnum[needIndex]); return median; }else{ if (i == needIndex+1){ median = Double.valueOf(insertnum[needIndex]+insertnum[needIndex+1]) /2.0; return median; } } } } return median; }} 分析这个方法优化的地方就是通过事先得到中间值的位置，在得到该位置的数值之后就不继续往下走了。 方法二：123456789101112131415161718192021222324252627282930public class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int N1 = nums1.length; int N2 = nums2.length; if (N1 &lt; N2) return findMedianSortedArrays(nums2, nums1); // Make sure A2 is the shorter one. if (N2 == 0) return ((double) nums1[(N1 - 1) / 2] + (double) nums1[N1 / 2]) / 2; // If A2 is empty int lo = 0, hi = N2 * 2; while (lo &lt;= hi) { int mid2 = (lo + hi) / 2; // Try Cut 2 int mid1 = N1 + N2 - mid2; // Calculate Cut 1 accordingly double L1 = (mid1 == 0) ? Integer.MIN_VALUE : nums1[(mid1 - 1) / 2]; // Get L1, R1, L2, R2 respectively double L2 = (mid2 == 0) ? Integer.MIN_VALUE : nums2[(mid2 - 1) / 2]; double R1 = (mid1 == N1 * 2) ? Integer.MAX_VALUE : nums1[(mid1) / 2]; double R2 = (mid2 == N2 * 2) ? Integer.MAX_VALUE : nums2[(mid2) / 2]; if (L1 &gt; R2) lo = mid2 + 1; // A1's lower half is too big; need to move C1 left (C2 right) else if (L2 &gt; R1) hi = mid2 - 1; // A2's lower half too big; need to move C2 left. else return ((L1 &gt; L2 ? L1 : L2) + (R1 &gt; R2 ? R2 : R1)) / 2; // Otherwise, that's the right cut. } return -1; } } 分析 这个问题比较困难，很多方法都是把他分成两种情况，奇数个和偶数个。实际上这样有点复杂，我们可以把这两个情况合并成一种情况。 首先，我们来重新定义一下’median’的含义： “如果我们把一个有序的array分成两个等长的部分，那么median就是比较小的那一部分的最大值和比较大的那一部分的最小值的平均值。即划分线两边的数。” 比如[1,2],我们的分割线就应该在1，2之间，[1 | 2],结果是(1 + 2)/2.0 = 1.5。同理，如果是两个有序的数组，那么我们只需要保证两个数组划分线右侧的数都大于左侧的数，并且两个数组左侧数字个数的和等于右侧数字个数的和。 我们使用‘|’来代表分割线，(n|n)来表示分割线正好在某个数字n上。比如[1 2 3],得到的分割后的数组像这样[1 (2|2) 3],z中间值就是(2+2)/2.0 = 2 我们使用L代表分割线左边的数，R代表分割线右边的数。 可以观察到左边的数和右边的数有这样的规律。 N Index of L / R1 0 / 02 0 / 13 1 / 14 1 / 25 2 / 26 2 / 37 3 / 38 3 / 4 可以得到 L = (N-1)/2, R = N/2. 中间值为(L + R)/2 = (A[(N-1)/2] + A[N/2])/2 为了更方便的计算两个数组的情况，我们添加一些空位在数字之间。用’#’代表，用’position’来表示增加空格后的位置信息。 [1 2] -&gt; [# 1 # 2 #] (N=2)position 0 1 2 3 4 (N_Position = 5) [3 4] -&gt; [# 3 # 4 #] (N=2)position 0 1 2 3 4 (N_Position = 5) 可以看出N_Position = 2N+1.所以分割线是在N，index(L) = (CutPosition-1)/2, index(R) = (CutPosition)/2. 当我们分割这两个数组的时候要注意，总共有2N1+2N2+2的位置，所以，分割线的每一边都要有N1+N2个位置，剩下的2个就是切线的位置，所以当我们A2分割线在 C2 = K , 那么A1的分割线就必须要在C1 = N1 + N2 - k. 比如, C2 = 2, 那么 C1 = 2 + 2 - C2 = 2. [# 1 | 2 #][# 3 | 4 #]现在我们有了两个L和两个R。L1 = A1[(C1-1)/2]; R1 = A1[C1/2];L2 = A2[(C2-1)/2]; R2 = A2[C2/2];即 L1 = A1[(2-1)/2] = A1[0] = 1; R1 = A1[2/2] = A1[1] = 2; L2 = A2[(2-1)/2] = A2[0] = 3; R2 = A1[2/2] = A1[1] = 4; 那么我们要怎么判断这个分割线是不是符合规则的呢？我们只要左边的数字都小于右边的数字。首先这两个数组都是有序的，所以L1,L2是左半边数组里最大的数，R1,R2是右半边数组里最小的数，L1&lt;=R1.L2&lt;=R2.所以我们只要判断L1&lt;=R2,L2&lt;=R1就可以了。 现在我们用简单的二分法查找就可以得到答案了。 如果L1&gt;R2,代表A1左边有过多较大的数字，我们必须把C1往左移，同时需要把C2往右移。如果L2&gt;R1,代表A2左边有过多较大的数字，我们必须把C2往左移，同时需要把C1往右移。反之则相反。 当我们找到正确的分割线位置的时候，中间值 = (max(L1, L2) + min(R1, R2)) / 2。 1.因为C1和C2可以根据彼此的值互相推断，我们可以使用较短的数组(设为A2)并且只移动C2，然后计算出C1。这样我们的时间复杂度就是O(log(min(N1, N2))) 2.只有在极限的条件下分割线会在0,或者2N的index。比如，C2=2N2,R2 = A2[2*N2/2] = A2[N2].这种情况下他有一边是没有数值的，我们可以把它当成是极大或者极小，L = INT_MIN ，R = INT_MAX. 时间复杂度 ： O(log(min(m,n))) 。m,n是两个数组的长度。空间复杂度 ： O(1) . 方法三：1234567891011121314151617181920212223242526272829303132333435363738public class Solution { public double findMedianSortedArrays(int A[], int B[]) { int n = A.length; int m = B.length; // the following call is to make sure len(A) &lt;= len(B). // yes, it calls itself, but at most once, shouldn't be // consider a recursive solution if (n &gt; m) return findMedianSortedArrays(B, A); // now, do binary search int k = (n + m - 1) / 2; int l = 0, r = Math.min(k, n); // r is n, NOT n-1, this is important!! while (l &lt; r) { int midA = (l + r) / 2; int midB = k - midA; if (A[midA] &lt; B[midB]) l = midA + 1; else r = midA; } // after binary search, we almost get the median because it must be between // these 4 numbers: A[l-1], A[l], B[k-l], and B[k-l+1] // if (n+m) is odd, the median is the larger one between A[l-1] and B[k-l]. // and there are some corner cases we need to take care of. int a = Math.max(l &gt; 0 ? A[l - 1] : Integer.MIN_VALUE, k - l &gt;= 0 ? B[k - l] : Integer.MIN_VALUE); if (((n + m) &amp; 1) == 1) return (double) a; // if (n+m) is even, the median can be calculated by // median = (max(A[l-1], B[k-l]) + min(A[l], B[k-l+1]) / 2.0 // also, there are some corner cases to take care of. int b = Math.min(l &lt; n ? A[l] : Integer.MAX_VALUE, k - l + 1 &lt; m ? B[k - l + 1] : Integer.MAX_VALUE); return (a + b) / 2.0; }} 分析这个方法的原理和上一个方法是大致相同的。时间复杂度 ： O(log(min(m,n))) 。m,n是两个数组的长度。空间复杂度 ： O(1) . 方法四：12345678910111213141516171819202122232425public class Solution { public double findMedianSortedArrays(int[] A, int[] B) { int m = A.length, n = B.length; int l = (m + n + 1) / 2;//position of l element (not the index) int r = (m + n + 2) / 2;//position of r element (not the index) return (getkth(A, 0, B, 0, l) + getkth(A, 0, B, 0, r)) / 2.0; } public double getkth(int[] A, int aStart, int[] B, int bStart, int k) { //when the start position is bigger than A.length -1 ,means the median doesn't in the A. if (aStart &gt; A.length - 1) return B[bStart + k - 1]; if (bStart &gt; B.length - 1) return A[aStart + k - 1]; if (k == 1) return Math.min(A[aStart], B[bStart]); int aMid = Integer.MAX_VALUE, bMid = Integer.MAX_VALUE; if (aStart + k/2 - 1 &lt; A.length) aMid = A[aStart + k/2 - 1]; if (bStart + k/2 - 1 &lt; B.length) bMid = B[bStart + k/2 - 1]; if (aMid &lt; bMid) return getkth(A, aStart + k/2, B, bStart, k - k/2);// Check: aRight + bLeft else return getkth(A, aStart, B, bStart + k/2, k - k/2);// Check: bRight + aLeft }} 分析这个方法的原理是这样的，从两个数组中间值开始通过递归对比，每次排除一半的选项。如果A的中间值小于B的中间值则保留a的右侧数字和b的左侧数字。反之相反。然后得到l和r位置的数字,再相加除以2即可。需要注意的是这里的l和r不是index，不是从零开始的。如果两个数组的长度的和是奇数的话l和r是相同的，偶数则不同。时间复杂度 ： O(log(m + n))空间复杂度 ： O(1) 如果你有更好的办法或者对我这里的描述有其他看法，请联系我。谢谢 About Me我的博客 leonchen1024.com 我的 GitHub https://github.com/LeonChen1024 微信公众号","link":"/2018/08/15/4-Median-of-Two-Sorted-Arrays/Record-cn/"},{"title":"LeetCode 3. Longest Substring Without Repeating Characters [English ver]","text":"[English ver] 3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Example:12345Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3.Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1.Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. First time i get a very tedious algorithm, because of i did not thinking about the problem carefully in the beginning, it causes that i hava to fix bug again and again because of the situation i haven’t think about . this makes code become very redundant . The solution for the first time123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution { public int lengthOfLongestSubstring(String s) { HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); int maxSubLength = 0; int tempLength = 0; boolean isFirstRepeat = true; String beginSub = \"\"; int bigStartNum = 0; for (int i=0;i&lt;s.length();i++){ beginSub = String.valueOf(s.charAt(i)); if(map.containsKey(beginSub)){ if(map.get(beginSub)&gt;bigStartNum){ tempLength = i - map.get(beginSub); bigStartNum = map.get(beginSub); }else{ tempLength = i - bigStartNum; } if(tempLength&gt;maxSubLength){ maxSubLength = tempLength; } if(isFirstRepeat){ tempLength = i; isFirstRepeat =false; if(tempLength&gt;maxSubLength){ maxSubLength = tempLength; } } }else{ tempLength = i - bigStartNum; if(tempLength&gt;maxSubLength){ maxSubLength = tempLength; } } map.put(beginSub,i); } if((s.length()-bigStartNum)&gt;maxSubLength){ maxSubLength = (s.length()-bigStartNum-1); } if(isFirstRepeat){ return s.length(); } return maxSubLength; }} i have thinking about did i have problems in the way i tried before, the twists before let me realize to think carefully and then write the code,i am not going to analyze this code, because i almost can’t understand what i writen, I even embarrassed to write the annotate, just leave A lesson to me. The next step i will optimize and rethink this approach. The solution for the second time12345678910111213141516171819202122public class Solution { public int lengthOfLongestSubstring(String s) { HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); //max substring's length int maxSubLength = 0; //the sub character now String nowSub = \"\"; //the bigger index which the string can start int bigStartNum = -1; for (int i=0;i&lt;s.length();i++){ nowSub = String.valueOf(s.charAt(i)); if(map.containsKey(nowSub)){ //if the character repeat,you can start the string from the larger one of the nowSub occur before this time and bigStartNum. bigStartNum = Math.max(map.get(nowSub), bigStartNum); } //the maxSubLength is the maximum number of the length of bigStartNum to i and old maxSubLength maxSubLength = Math.max(i - bigStartNum, maxSubLength); map.put(nowSub,i); } return maxSubLength; }} After the optimize ,the code is very clear. I haven’t thought that there is a Math.max () method can be used util i re-conceived the code, still need more sensitivity of the api. AnalysisThe principle of this method is to traverse each character, in order to avoid nest loop, we use the hashmap to replace the time cost of space costs,determine whether there is a character in front by hashmap, and store his index number information. How do we get the longest substring? In fact, it can be divided into the following situations: We use (p) to represent the previous repeat character, (n) to represent the latter repeat character. The character a is the first repeat character, and the length should be from the beginning to the location a(n)-1. the character a is not the first repeat character, the last repeat character is b, if a(p) is behind b(p) then the length is between two a, if a(p) is in front of b(p), then the length is between a(n) and b(p) (because a(n) to a(p) contains two b, which is irregular) This character does not repeat, the length is the character to location of the last repeat character a(p)+1. Sort out the current situation util now .in fact, the conditions above can be sorted into one way to calculate, because the sub-string must be continuous, so it is to calculate the length between current character and the repeat character previous one ,and then get the largest length. Time complexity: O(n).Space complexity: O(n). and then we look some type solution of this kind problem. Approach 1：Brute Force123456789101112131415161718192021public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(); int ans = 0; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt;= n; j++) if (allUnique(s, i, j)) ans = Math.max(ans, j - i); return ans; } //judge that all the characters in s is unique. public boolean allUnique(String s, int start, int end) { Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int i = start; i &lt; end; i++) { Character ch = s.charAt(i); if (set.contains(ch)) return false; set.add(ch); } return true; }} AnalysisThe principle of this method is very simple, the outermost loop L1 traverse of every character a, nest a loop L2 traverse of b (all the characters which is after a), use another loop with the hashset to traverse all the string between a and b which is beginning with a, and determine that if it is a string with no repeat character. Nested a three-tier loop! it lead to the results of Time Limit Exceeded, that means your method is too time-consuming, is not a good method. Time complexity: O(n^3) . The first is the innermost [i, j) times cycle, the time complexity is O(j-i). And then is every cycle of j which takes [i + 1, n),123n∑ O(j−i)i+1 Finally count the outermost loop [0, n). The time complexity is123 n-1 n n-1 (1+n-i)(n-i)O( ∑ ( ∑ (j-i))) = O(∑ —————————————— ) = O(n^3) i=0 j=i+1 i=0 2 This transformation process is actually the use of the sum of the first n terms of an arithmetic progression, is too difficult to print the formula on my computer, i am not going to print the detail of the steps . Space complexity: O(min(n,m)) . n is the length of the string,m is the set of the size of charset.Because there are m didn’t repeat value at most,so the hashset’s size will be m at most. This method can make a little optimization logically , the main idea is that if from a to b is already containing repeated characters, then a to the characters after b must also contain repeated characters. You can omit those comparisons. Approach 2：Sliding Window（K-Nearest Neighbor algorithm）123456789101112131415161718public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int ans = 0, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) { // try to extend the range [i, j] if (!set.contains(s.charAt(j))){ set.add(s.charAt(j++)); ans = Math.max(ans, j - i); } else { set.remove(s.charAt(i++)); } } return ans; }} Analysis Method 1 is repeatly to check each sub-string has duplicate character,but in fact, it is unnecessary, the second method is avoid repeated checks, when i ~ j has not repeat, we only need to check s[j + 1] is already in i ~ j characters . Until the characters of j + 1 is already in i~j, we get the longest non-repetitive substring which start with i character. we can stop the calculation When j is not less than n , because at this time [i, j) must be longer than [i + 1, j). Time complexity: O(2n) = O(n)Space complexity: O(min(m,n)) n is the length of the string,m is the size of the charset.Because there are m didn’t repeat value at most,so the hashset’s size will be m at most. ####Approach 3:Sliding Window Optimized HashMap123456789101112131415public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(), ans = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) { if (map.containsKey(s.charAt(j))) { i = Math.max(map.get(s.charAt(j)), i); } ans = Math.max(ans, j - i + 1); map.put(s.charAt(j), j + 1); } return ans; }} Analysis This method is the improvement of the method two, we use the HashMap to save the characters and his position, when there are duplicate characters appeared, we can directly locate the location of the repeated characters (Note that the location here and the program’s index number is different , it’s first is 1 rather than our program is 0.), compared to the previous i and take a larger value assigned to the new i. Why should we take a large value can see the above solution for the second time. Time complexity： O(n)Space complexity： O(min(m,n)) the same to the method 2 ASCII 12812345678910111213public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(), ans = 0; int[] index = new int[128]; // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) { i = Math.max(index[s.charAt(j)], i); ans = Math.max(ans, j - i + 1); index[s.charAt(j)] = j + 1; } return ans; }} The most efficient one, the reason of this method can run more fast than the previous hashmap while they have the same complexity, simply said, in fact of most collection is composed of arrays, hashmap is actually composed by the array and the list , So the array’s search speed will be better than the hashmap search speed. 分析 This method’s principle is almost the same as the previous method which is using hashmap, but this method uses int[] to store key-value pairs, using characters to represent subscripts (yes, characters can be used as subscripts, exactly is Integer character constants can be used as subscript, it will be parsed to ASCII value), the location use as value.Time complexity： O(n)Space complexity： O(m) m is the charset’s size. If you have a better method or have other opinions on the description of me here, please contact me. Thank you. About MeMy blog leonchen1024.com My Github https://github.com/LeonChen1024","link":"/2018/07/21/3-Longest-Substring-Without-Repeating-Characters/Record[English-ver]/"},{"title":"LeetCode 4. Median of Two Sorted Arrays [English ver]","text":"[English ver] 4. Median of Two Sorted ArraysThere are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 12345Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0 12345Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 Approach 1:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { //how many number we need int needNum = 0; //the index of the number we need int needIndex = 0; //the median value double median = 0; int big = 0; int stand = 0; //the total array int[] insertnum ; int m = nums1.length; int n = nums2.length; if((m+n)%2==0){ needNum = 2; needIndex = (m+n)/2-1; }else{ needNum=1; needIndex = (m+n)/2; } insertnum = new int[m+n]; //nums1 index int j =0; //nums2 index int k = 0; for(int i =0;i&lt;m+n;i++){ if(k==n){ insertnum[i] = nums1[j]; j++; } else if(j==m){ insertnum[i] = nums2[k]; k++; }else if(nums1[j]&gt;nums2[k]){ insertnum[i] = nums2[k]; k++; }else{ insertnum[i] = nums1[j]; j++; } } if(needNum == 1){ median = Double.valueOf(insertnum[needIndex]); }else{ median = Double.valueOf(insertnum[needIndex]+insertnum[needIndex+1]) /2.0; } return median; }} by the way ,this method often failed , maybe is the complexity is too big. AnalysisThis method is easy,first we figure out how to get the median value and how many number we need for calculate median value when the sum of the two arrays size is odd-lengthed or even-lengthed. And then we put the two arrays together sorted from small to large , and then use the method we got to calculate the median value. Time complexity: O(m+n)Space complexity:O(m+n) we can have a optmization of this approach,like that 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int needNum = 0; int needIndex = 0; double median = 0; int big = 0; int stand = 0; int[] insertnum ; int m = nums1.length; int n = nums2.length; if((m+n)%2==0){ needNum = 2; needIndex = (m+n)/2-1; }else{ needNum=1; needIndex = (m+n)/2; } insertnum = new int[(m+n)/2+1]; int j =0; int k = 0; for(int i =0;i&lt;m+n;i++){ if(k==n){ insertnum[i] = nums1[j]; j++; } else if(j==m){ insertnum[i] = nums2[k]; k++; }else if(nums1[j]&gt;nums2[k]){ insertnum[i] = nums2[k]; k++; }else{ insertnum[i] = nums1[j]; j++; } if (i &gt;= needIndex ){ if (needNum == 1){ median = Double.valueOf(insertnum[needIndex]); return median; }else{ if (i == needIndex+1){ median = Double.valueOf(insertnum[needIndex]+insertnum[needIndex+1]) /2.0; return median; } } } } return median; }} Analysis The optmization is we get the index of the median value , when we sorted the array to the index , we can calculate the median value and we don’t need to sorted all the number. Approach 2123456789101112131415161718192021222324252627282930public class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int N1 = nums1.length; int N2 = nums2.length; if (N1 &lt; N2) return findMedianSortedArrays(nums2, nums1); // Make sure A2 is the shorter one. if (N2 == 0) return ((double) nums1[(N1 - 1) / 2] + (double) nums1[N1 / 2]) / 2; // If A2 is empty int lo = 0, hi = N2 * 2; while (lo &lt;= hi) { int mid2 = (lo + hi) / 2; // Try Cut 2 int mid1 = N1 + N2 - mid2; // Calculate Cut 1 accordingly double L1 = (mid1 == 0) ? Integer.MIN_VALUE : nums1[(mid1 - 1) / 2]; // Get L1, R1, L2, R2 respectively double L2 = (mid2 == 0) ? Integer.MIN_VALUE : nums2[(mid2 - 1) / 2]; double R1 = (mid1 == N1 * 2) ? Integer.MAX_VALUE : nums1[(mid1) / 2]; double R2 = (mid2 == N2 * 2) ? Integer.MAX_VALUE : nums2[(mid2) / 2]; if (L1 &gt; R2) lo = mid2 + 1; // A1's lower half is too big; need to move C1 left (C2 right) else if (L2 &gt; R1) hi = mid2 - 1; // A2's lower half too big; need to move C2 left. else return ((L1 &gt; L2 ? L1 : L2) + (R1 &gt; R2 ? R2 : R1)) / 2; // Otherwise, that's the right cut. } return -1; } } Analysis this method is a little hard to understand,many implementations consider odd-lengthed and even-lengthed arrays as two different cases and treat them separately. In fact , this is a little twist.First, we can define ‘MEDIAN’ i: “if we cut the sorted array to two halves of equal length, then median is the average of the max number of the small half and min of larger half , is the number near to the cut . For example, for [ 1 2 ], we make the cut between 1 and 2:[1 | 2]the median = (1+2)/2.0 = 1.5 .The same to the two arrays , we only need to make sure numbers in the right side of the cut of the two arrays bigger than the left side of the cut ,and the size of the left is equal to the size of the right .I’ll use ‘|’ to represent a cut, and (number | number) to represent a cut made through a number in this article. for example , [1 2 3],the cut is like [1 (2|2) 3].the median = (2+2)/2.0 = 2. now we use ‘L’ to represent the number in the left of the cut ,’R’ to represent the number in the right. we can found that N Index of L / R1 0 / 02 0 / 13 1 / 14 1 / 25 2 / 26 2 / 37 3 / 38 3 / 4 It is not hard to conclude that index of L = (N-1)/2, and R = N/2. the median = (L + R)/2 = (A[(N-1)/2] + A[N/2])/2 To get ready for the two array situation,we add a few empty number (represented as ‘#’) in between numbers. and use ‘positions’ to represented the position of that . [1 2] -&gt; [# 1 # 2 #] (N=2)position 0 1 2 3 4 (N_Position = 5) [3 4] -&gt; [# 3 # 4 #] (N=2)position 0 1 2 3 4 (N_Position = 5) there are always 2*N+1 ‘positions’ of which array length is N. Therefore, the middle cut should be made on the Nth position (0-based). index(L) = (CutPosition-1)/2, index(R) = (CutPosition)/2. notice that, when we cut the two arrays there are 2N1+2N2+2 positions,so,each side of the cut should be N1+N2 positions, the two position lefted is the cut . so when A2’s cut is at C2 = K , than A1’s cut should be C1 = N1 + N2 -K,for example ,C2 = 2, 那么 C1 = 2 + 2 - C2 = 2. [# 1 | 2 #][# 3 | 4 #] now we have two L and two R. L1 = A1[(C1-1)/2]; R1 = A1[C1/2];L2 = A2[(C2-1)/2]; R2 = A2[C2/2]; L1 = A1[(2-1)/2] = A1[0] = 1; R1 = A1[2/2] = A1[1] = 2;L2 = A2[(2-1)/2] = A2[0] = 3; R2 = A1[2/2] = A1[1] = 4; How can we figure out this cut is the cut we want ?the numbers in left side must be smaller than the numbers in right side .Because A1 and A2 is sorted , L1 &lt;= R1 &amp;&amp; L2 &lt;= R2.so we only need to confirm that L1 &lt;= R2 and L2 &lt;= R1. Now we can use binary search to find out the result. If L1 &gt; R1, it means there are too many large numbers on the left half of A1, then we must move C1 to the left at the same time move C2 to the right;If L2 &gt; R1, then there are too many large numbers on the left half of A2, and we must move C2 to the left , and move C1 to the right .Otherwise, make it opposite. After we find the cut, the medium can be computed as (max(L1, L2) + min(R1, R2)) / 2; since C1 and C2 can be mutually determined from each other, we might as well select the shorter array (say A2) and only move C2 around, and calculate C1 accordingly. That way we can achieve a run-time complexity of O(log(min(N1, N2))) The only edge case is when a cut falls on the 0th(first) or the 2Nth(last) position. For instance, if C2 = 2N2, then R2 = A2[2*N2/2] = A2[N2], which exceeds the boundary of the array. To solve this problem, we can imagine that both A1 and A2 actually have two extra elements, INT_MAX at A[-1] and INT_MAX at A[N]. Time complexity ： O(log(min(m,n))) 。m,n is the length of the two arrays.space complexity ： O(1) . Approach 3：1234567891011121314151617181920212223242526272829303132333435363738public class Solution { public double findMedianSortedArrays(int A[], int B[]) { int n = A.length; int m = B.length; // the following call is to make sure len(A) &lt;= len(B). // yes, it calls itself, but at most once, shouldn't be // consider a recursive solution if (n &gt; m) return findMedianSortedArrays(B, A); // now, do binary search int k = (n + m - 1) / 2; int l = 0, r = Math.min(k, n); // r is n, NOT n-1, this is important!! while (l &lt; r) { int midA = (l + r) / 2; int midB = k - midA; if (A[midA] &lt; B[midB]) l = midA + 1; else r = midA; } // after binary search, we almost get the median because it must be between // these 4 numbers: A[l-1], A[l], B[k-l], and B[k-l+1] // if (n+m) is odd, the median is the larger one between A[l-1] and B[k-l]. // and there are some corner cases we need to take care of. int a = Math.max(l &gt; 0 ? A[l - 1] : Integer.MIN_VALUE, k - l &gt;= 0 ? B[k - l] : Integer.MIN_VALUE); if (((n + m) &amp; 1) == 1) return (double) a; // if (n+m) is even, the median can be calculated by // median = (max(A[l-1], B[k-l]) + min(A[l], B[k-l+1]) / 2.0 // also, there are some corner cases to take care of. int b = Math.min(l &lt; n ? A[l] : Integer.MAX_VALUE, k - l + 1 &lt; m ? B[k - l + 1] : Integer.MAX_VALUE); return (a + b) / 2.0; }} Analysisthis method’s principle is same as the Approach 2. Time complexity ： O(log(min(m,n))) 。m,n is the length of the two arrays.space complexity ： O(1) . Approach 4:12345678910111213141516171819202122232425public class Solution { public double findMedianSortedArrays(int[] A, int[] B) { int m = A.length, n = B.length; int l = (m + n + 1) / 2;//position of l element (not the index) int r = (m + n + 2) / 2;//position of r element (not the index) return (getkth(A, 0, B, 0, l) + getkth(A, 0, B, 0, r)) / 2.0; } public double getkth(int[] A, int aStart, int[] B, int bStart, int k) { //when the start position is bigger than A.length -1 ,means the median doesn't in the A. if (aStart &gt; A.length - 1) return B[bStart + k - 1]; if (bStart &gt; B.length - 1) return A[aStart + k - 1]; if (k == 1) return Math.min(A[aStart], B[bStart]); int aMid = Integer.MAX_VALUE, bMid = Integer.MAX_VALUE; if (aStart + k/2 - 1 &lt; A.length) aMid = A[aStart + k/2 - 1]; if (bStart + k/2 - 1 &lt; B.length) bMid = B[bStart + k/2 - 1]; if (aMid &lt; bMid) return getkth(A, aStart + k/2, B, bStart, k - k/2);// Check: aRight + bLeft else return getkth(A, aStart, B, bStart + k/2, k - k/2);// Check: bRight + aLeft }} Analysisthis method is like that, compare the two arrays’s median recursively, and every time ignore a half of the two arrays. if A’s median is smaller than B’s median , then we keep A’s right and B’s left.Otherwise opposite. last ,we will get L and R , use (L+R)/2.0 to get the median.notice that L and R is not index, isn’t start from 0 . when the numbers of the sum of two array’s size is odd-lengthed L is the same as R,Otherwise is different. Time complexity ： O(log(m + n))Space complexity ： O(1) If you have any suggestions to make the logic and implementation more better , or you have some advice on my description. Please let me know! About MeMy blog leonchen1024.com My Github https://github.com/LeonChen1024","link":"/2018/08/15/4-Median-of-Two-Sorted-Arrays/Record-en/"},{"title":"LeetCode 6. 锯齿形转换","text":"[Chinese ver] 6. ZigZag Conversion字符串”PAYPALISHIRING”是通过一个如下给定行数的锯齿模式书写的:(你可能想要使用一个固定的字体来更好的显示它) 123P A H NA P L S I I GY I R 然后一行一行的读取这个字符串:”PAHNAPLSIIGYIR”编写代码实现获取一个字符串然后根据给出的行数来实现这个锯齿转换:1string convert(string text, int nRows); convert(“PAYPALISHIRING”, 3) 应该返回 “PAHNAPLSIIGYIR”. 首先我们来分析下什么是zigzag pattern,zigzag是锯齿或之字形的意思。是以一定的角度相交的两条线依次以其平行线进行重复相交的线路。一开始我以为是中间都是一行然后旁边是锯齿，当为4行的情况如下(以数字作为字符的index): 123451 7 132 8 143 6 9 12 154 10 165 11 17 但是事实并不是这样的，zigzag pattern 4行的情况应该是如下：12341 7 132 6 8 12 143 5 9 11 154 10 16 字符以这种锯齿形分布。 方法一 使用String[]：123456789101112131415161718192021222324252627282930313233public class Solution { public String convert(String s, int numRows) { String result = \"\"; String[] strings = new String[numRows]; for (int i =0;i&lt;numRows;i++){ strings[i] = \"\"; } int position = 0 ; int numRowsIndex = numRows-1; int step = 1; //if the numRows is one ,or the s's length is less than numRows ,return s . if (numRows ==1 || s.length()&lt;numRows){ return s; } //loop the every char in the String, when the position is 0,the step is one ,is the position is numRowsIndex,the step is negative one for (int i =0;i&lt;s.length();i++){ strings[position] += s.charAt(i); if (position ==0){ step = 1; } if (position == numRowsIndex ){ step = -1; } position = position+step; } for (int i =0;i&lt;numRows;i++){ result += strings[i]; } return result; }} 分析这个方法将每一行的字符串存入对应的String[i]中，最后在将String[]按顺序拼接起来就得到了我们要的结果。当目前的位置在第一行的时候，下一个位置应该向下移动，所以step =1 . 当位置在最后一行的时候，下一个位置应该向上移动，所以step =-1.时间复杂度 ： O(n) 。n是字符串的长度空间复杂度 ： O(n) . 方法二 StringBuilder[]：1234567891011121314151617181920212223242526272829303132public class Solution { public String convert(String s, int numRows) { StringBuilder result = new StringBuilder(\"\"); StringBuilder[] strings = new StringBuilder[numRows]; for (int i =0;i&lt;numRows;i++){ strings[i] = new StringBuilder(\"\"); } int position = 0 ; int numRowsIndex = numRows-1; int step = 1; //if the numRows is one ,or the s's length is less than numRows ,return s . if (numRows ==1 || s.length()&lt;numRows){ return s; } //loop the every char in the String, when the position is 0,the step is one ,is the position is numRowsIndex,the step is negative one for (int i =0;i&lt;s.length();i++){ strings[position].append(s.charAt(i)); if (position ==0){ step = 1; } if (position == numRowsIndex ){ step = -1; } position = position+step; } for (int i =0;i&lt;numRows;i++){ result.append(strings[i]); } return result.toString(); }} 分析这个方法原理和方法一一样，只是把String 换成 StringBuilder来处理，效率有了很大的提高 时间复杂度 ： O(n) 。n是字符串的长度空间复杂度 ： O(n) . 方法三 间隔算法12345678910111213141516171819202122232425262728293031public class Solution { public String convert(String s, int numRows) { String result=\"\"; if(numRows==1) return s; int step1,step2; int len=s.length(); for(int i=0;i&lt;numRows;++i){ step1=(numRows-i-1)*2; step2=(i)*2; int pos=i; if(pos&lt;len) result+=s.charAt(pos); while(true){ pos+=step1; if(pos&gt;=len) break; if(step1&gt;0) result+=s.charAt(pos); pos+=step2; if(pos&gt;=len) break; if(step2&gt;0) result+=s.charAt(pos); } } return result; }} 分析123456789/*n=numRowsΔ=2n-2 1 2n-1 4n-3Δ= 2 2n-2 2n 4n-4 4n-2Δ= 3 2n-3 2n+1 4n-5 .Δ= . . . . .Δ= . n+2 . 3n .Δ= n-1 n+1 3n-3 3n-1 5n-5Δ=2n-2 n 3n-2 5n-4*/ 这个方法主要是通过间隔的规律来进行计算和排位。 时间复杂度 ： O(n) 。n是字符串长度空间复杂度 ： O(n) . 如果你有更好的办法或者对我这里的描述有其他看法，请联系我。谢谢 About Me我的博客 leonchen1024.com 我的 GitHub https://github.com/LeonChen1024 微信公众号","link":"/2018/09/12/6-ZigZag-Conversion/Record-cn/"},{"title":"LeetCode 3.最长的没有重复字符的子字符串 [Chinese ver]","text":"[Chinese ver] 3.最长的没有重复字符的子字符串给你一个字符串，得出最长的一个没有重复字符的子字符串的长度。 例子： 给定“abcabcbb”，答案是“abc”，长度为3。 给定“bbbbb”，答案是“b”，长度为1。 给定“pwwkew”，答案是“wke”，长度为3. 注意答案必须是一个子字符串，“pwke”是一个子序列，而不是一个子字符串。 先来一个极其繁琐的算法，一开始没有经过太多的思考，导致不断有没考虑到情况发生，不断的修修改改，成了一个极其冗余的代码。。 初解123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution { public int lengthOfLongestSubstring(String s) { HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); int maxSubLength = 0; int tempLength = 0; boolean isFirstRepeat = true; String beginSub = \"\"; int bigStartNum = 0; for (int i=0;i&lt;s.length();i++){ beginSub = String.valueOf(s.charAt(i)); if(map.containsKey(beginSub)){ if(map.get(beginSub)&gt;bigStartNum){ tempLength = i - map.get(beginSub); bigStartNum = map.get(beginSub); }else{ tempLength = i - bigStartNum; } if(tempLength&gt;maxSubLength){ maxSubLength = tempLength; } if(isFirstRepeat){ tempLength = i; isFirstRepeat =false; if(tempLength&gt;maxSubLength){ maxSubLength = tempLength; } } }else{ tempLength = i - bigStartNum; if(tempLength&gt;maxSubLength){ maxSubLength = tempLength; } } map.put(beginSub,i); } if((s.length()-bigStartNum)&gt;maxSubLength){ maxSubLength = (s.length()-bigStartNum-1); } if(isFirstRepeat){ return s.length(); } return maxSubLength; }} 痛定思过，惨痛的教训告诉我们要深思熟虑后再写代码，这个代码就不分析了，写出来的东西自己都要看不懂了，我连注释都不好意思写了，只是给自己留个教训。。接下来会对这个方法做一个优化和重新构思。 二次解12345678910111213141516171819202122public class Solution { public int lengthOfLongestSubstring(String s) { HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); //max substring's length int maxSubLength = 0; //the sub character now String nowSub = \"\"; //the bigger index which the string can start int bigStartNum = -1; for (int i=0;i&lt;s.length();i++){ nowSub = String.valueOf(s.charAt(i)); if(map.containsKey(nowSub)){ //if the character repeat,you can start the string from the larger one of the nowSub occur before this time and bigStartNum. bigStartNum = Math.max(map.get(nowSub), bigStartNum); } //the maxSubLength is the maximum number of the length of bigStartNum to i and old maxSubLength maxSubLength = Math.max(i - bigStartNum, maxSubLength); map.put(nowSub,i); } return maxSubLength; }} 优化之后的代码就很清晰了。重新构思的时候才想到还有一个Math.max()的方法可以用，对api的敏感度还是不够。 分析这个方法的原理就是将每一个字符进行遍历，为了避免多重循环嵌套，我们使用了hashmap来将时间成本换成空间成本，通过hashmap来判断前面是否有这个字符，并存储他的序号信息。那怎么得到最长的子字符串呢？其实可以分成以下几种情况：我们在前一个重复的字符加上(p)来表示,后一个重复的字符加上(n)来表示1.这个字符是第一个重复的字符a，长度应该是从开始到a(n)的前一位。2.这个字符不是第一个重复的字符a,上一个重复的字符为b，如果a(p)在b(p)的后面那么长度是两个a之间的长度，如果a(p)在b(p)的前面，那么长度是a(n)到b(p)之间(因为a(n)到a(p)之间包含了两个b，这样的字符串是不合规矩的)3.这个字符没有出现重复的情况，长度就是这个字符到上一个重复字符a(p)出现的位置加一。 整理一下现在的情况，其实以上的条件都可以整理成一种方式来计算，因为子字符串必须是连续的，所以就是计算当前字符到上一个任意重复字符点的长度，然后取出最大的一个。 时间复杂度 ： O(n) .空间复杂度 ： O(n) . 接下来我们看一下这类题目的几类解法。 方法一：暴力循环123456789101112131415161718192021public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(); int ans = 0; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt;= n; j++) if (allUnique(s, i, j)) ans = Math.max(ans, j - i); return ans; } //judge that all the characters in s is unique. public boolean allUnique(String s, int start, int end) { Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int i = start; i &lt; end; i++) { Character ch = s.charAt(i); if (set.contains(ch)) return false; set.add(ch); } return true; }} 分析这个方法的原理很简单，就是最外层的循环L1遍历每一个字符a，嵌套一个遍历a之后所有字符b的循环L2，在L2中又用了一个循环L3用hashset的方式来遍历a到b间以a为开头的所有字符串，并判断是否是没有重复值的字符串。嵌套了三层的循环！！！直接导致了Time Limit Exceeded 的结果，表示你这个方法太耗时了，不予通过。时间复杂度 ： O(n^3) . 首先是最内层的[i,j)次的循环，时间复杂度为O(j-i)。然后是每一个j的循环[i+1,n),123n∑ O(j−i)i+1 最后算上最外层的a的循环[0,n).时间复杂度为123 n-1 n n-1 (1+n-i)(n-i)O( ∑ ( ∑ (j-i))) = O(∑ —————————————— ) = O(n^3) i=0 j=i+1 i=0 2 这个转化过程呢其实就是利用的等差数列的n项和公式，太难打公式了，中间步骤就不详细写了。 空间复杂度 ： O(min(n,m)) . n就是字符串的长度，m是字母表的字符集的值。因为我们最多就可能有m个不重复的值，所以hashset的size最大也只会是m. 这个方法在逻辑上可以稍微做一个优化，主要的思路就是其实如果a到b已经是包含重复的字符了，那么a到b后面的字符也一定是包含重复字符的。可以省略了那些比较。 方法二：滑窗算法（也称K近邻算法）123456789101112131415161718public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int ans = 0, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) { // try to extend the range [i, j] if (!set.contains(s.charAt(j))){ set.add(s.charAt(j++)); ans = Math.max(ans, j - i); } else { set.remove(s.charAt(i++)); } } return ans; }} 分析方法一重复检查每一个子字符串是否重复，其实没有必要这样，方法二就是避免了多次重复检查，当i~j没有重复时，我们只需要检测s[j + 1]是否和i~j中的字符重复。直到j+1的字符重复了，我们就得到了i字符的最长不重复字符。当j不小于n时就可以停止计算了，因为此时的[i,j)肯定要长于[i+1,j)。 时间复杂度 ： O(2n) = O(n)空间复杂度 ： O(min(m,n)) n就是字符串的长度，m是字母表的字符集的值。因为我们最多就可能有m个不重复的值，所以hashset的size最大也只会是m. 方法三：改良后的滑窗算法HashMap123456789101112131415public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(), ans = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) { if (map.containsKey(s.charAt(j))) { i = Math.max(map.get(s.charAt(j)), i); } ans = Math.max(ans, j - i + 1); map.put(s.charAt(j), j + 1); } return ans; }} 分析这个方法是对方法二的改进，我们使用HashMap来保存出现的字符和他的位置，当出现重复字符时，我们可以直接定位到重复字符的位置(注意这里的位置和程序上的序号是不同的，他的第一位就是1而不是我们程序上的0.)，对比以前的i取较大的值赋值为新的i。为什么取大值可以看上面的二次解 时间复杂度 ： O(n)空间复杂度 ： O(min(m,n)) 和方法二相同 ASCII 12812345678910111213public class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(), ans = 0; int[] index = new int[128]; // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) { i = Math.max(index[s.charAt(j)], i); ans = Math.max(ans, j - i + 1); index[s.charAt(j)] = j + 1; } return ans; }} 效率最快的一种，在同样的复杂度上为什么会比上一种hashmap的方法快那么多呢，简单点说，其实集合大部分都是由数组构成的，hashmap其实就是由数组加链表封装而成的，所以在速度上数组查找会优于hashmap查找。 分析这个方法原理和上一个使用hashmap的方法大致相同，但是它使用的是int[]来存储键值对，使用字符来做下标(是的，字符可以做下标，准确的来说是整型字符常量可以做下标，会被解析为他的ASCII码值)，位置来做值。 时间复杂度 ： O(n)空间复杂度 ： O(m) m是字符表的大小 如果你有更好的办法或者对我这里的描述有其他看法，请联系我。谢谢 About Me我的博客 leonchen1024.com 我的 GitHub https://github.com/LeonChen1024 微信公众号","link":"/2018/07/21/3-Longest-Substring-Without-Repeating-Characters/Record[Chinese-ver]/"},{"title":"LeetCode 5.最长的回文字符串","text":"5. Longest Palindromic Substring给定一个字符串s,找出其中最长的回文格式的子字符串。你可以假设长度的最大值为1000. Example:123Input: &quot;babad&quot;Output: &quot;bab&quot; Note: “aba” is also a valid answer. Example:123Input: &quot;cbbd&quot;Output: &quot;bb&quot; 一开始以为palindrome是重复的意思，走了很大的弯路，后来才知道指的是回文格式，就是一个顺着读和反过来读都一样的字符串。由此可知他有两种情况，一种是奇数的情况，中间的一个字符独立，其余的字符以中间为轴两两对应。另一种是偶数的情况，所有的字符都以中间为轴两两对应。 方法一：1234567891011121314151617181920212223242526public class Solution { private int lo, maxLen; public String longestPalindrome(String s) { int len = s.length(); if (len &lt; 2) return s; for (int i = 0; i &lt; len - 1; i++) { extendPalindrome(s, i, i); //assume odd length, try to extend Palindrome as possible extendPalindrome(s, i, i + 1); //assume even length. } return s.substring(lo, lo + maxLen); } private void extendPalindrome(String s, int j, int k) { while (j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k)) { j--; k++; } if (maxLen &lt; k - j - 1) { lo = j + 1; maxLen = k - j - 1; } } } 分析这个方法分为奇偶两种情况进行计算。首先对每一个字符串里的字符进行两种情况的计算，extendPalindrome方法的原理就是当对应的位置的字符相同时，就将左侧字符向左一位，右侧字符向右一位，然后再重复进行这个比较过程。时间复杂度 ： O(n^2) 。n是字符串的长度空间复杂度 ： O(n) . 方法二：12345678910111213141516171819202122232425public class Solution { public String longestPalindrome(String s) { String res = \"\"; int currLength = 0; for(int i=0;i&lt;s.length();i++){ if(isPalindrome(s,i-currLength-1,i)){ res = s.substring(i-currLength-1,i+1); currLength = currLength+2; } else if(isPalindrome(s,i-currLength,i)){ res = s.substring(i-currLength,i+1); currLength = currLength+1; } } return res; } public boolean isPalindrome(String s, int begin, int end){ if(begin&lt;0) return false; while(begin&lt;end){ if(s.charAt(begin++)!=s.charAt(end--)) return false; } return true; }} 分析这个方法主要是每当指针向右移时，我们都以这个位置的字符为结尾看是否能有新的长度为length(current length +1 或者 current length +2)的回文字符串。 时间复杂度 ： O(n^2) 。n是字符串长度。空间复杂度 ： O(n) . 方法三 Manacher算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class Solution { public String longestPalindrome(String s) { char[] str = changeString(s); String result = manacher(str,s); return result;}/** * 返回例如 #a#c#b#c#a#a#c#b#c#d#形式的字符串数组 * * @param s * @return */ public static char[] changeString(String s) { char[] str = new char[s.length() * 2 + 1]; int i = 0; for (; i &lt; s.length(); i++) { str[2 * i] = '#'; str[2 * i + 1] = s.charAt(i); } str[2 * i] = '#'; return str; } /** * manacher 算法实现找到回文字符串最长的一个 */ public static String manacher(char[] s,String olds) { String result = \"\"; int rad[] = new int[s.length]; int start = 0; int end = 0; //i index,j 回文半径，k int i = 1, j = 0, k; // 记录最长的回文串的长度 int maxLen = 0; while (i &lt; s.length) { // 扫描得出rad值 while (i - j - 1 &gt; -1 &amp;&amp; i + j + 1 &lt; s.length &amp;&amp; s[i - j - 1] == s[i + j + 1]) { j++; } if (maxLen &lt; j ) { maxLen =j; start = i - j ; end =i + j ; } rad[i] = j; maxLen = maxLen &gt; j ? maxLen : j; k = 1; //当回文中包含子回文，看子回文是否超出父回文边界。 分三种情况。 while (k &lt;= rad[i] &amp;&amp; rad[i - k] != rad[i] - k) { rad[i + k] = Math.min(rad[i - k], rad[i] - k); k++; } i = i + k; j = Math.max(j - k, 0); } result = olds.substring(start/2,end/2); return result; }} 分析在这个问题中，回文的情况一共有两种，一种是奇数回文，一种是偶数回文，为了将他们合并成一种情况，我们可以在首尾和每两个字符中间加上一个特殊字符，如‘#’，形如”#a#b#b#c#a#”.这样我们就将所有的回文情况合并成奇数回文的情况。 在字符串s中，我们用rad[i]表示第i个字符的回文半径，可以得到s[i-rad[i],i-1] = s[i+1,i+rad[i]]，只要求出了所有的rad，就求出了所有奇数长度的回文子串。 当我们得到了rad[1..i-1]的值，并通过比较对称字符得到当前字符i的rad值至少为j，求出了rad[i]。现在我们设一个指针k，从1循环到rad[i]，以此来求出[i+1,i+rad[i]]的rad值。 根据定义，黑色的部分是一个回文子串，两段红色的区间全等。因为之前已经求出了rad[i-k]，所以直接用它.有3种情况：（1）rad[i]-k &lt; rad[i-k] 如图,rad[i-k]的范围为墨绿色。因为黑色的部分是回文的，且墨绿色的部分超过了黑色的部分，所以rad[i+k]至少为rad[i]-k，即橙色的部分。有没有可能rad[i+k]的值大于rad[i]-k呢？这是不可能发生的，根据回文的特性我们知道，如果橙色部分以外也是回文，那么黑色的回文部分就可以向外拓展。与假设冲突。因此rad[i+k] = rad[i]-k。 （2）rad[i]-k &gt; rad[i-k] 如图,rad[i-k]的范围为墨绿色。因为黑色的部分是回文的，且墨绿色的部分在黑色的部分里面，根据回文特性，很容易得出：rad[i+k] = rad[i-k]。 根据上面两种情况，可以得出结论：当rad[i]-k != rad[i-k]的时候，rad[i+k] = min(rad[i]-k,rad[i-k])。 （3）rad[i]-k = rad[i-k]如图，通过和第一种情况对比之后会发现，因为墨绿色的部分没有超出黑色的部分，所以即使橙色的部分全等，也无法像第一种情况一样引出矛盾，因此橙色的部分是有可能全等的。但是，根据已知的信息，我们不知道橙色的部分是多长，因此就把i指针移到i+k的位置，j=rad[i-k](因为它的rad值至少为rad[i-k])，是否可以向外拓展等下个循环再做。 时间复杂度 ： O(n) 。看起来程序里用到了循环嵌套，但是实际上他只对没有计量过的i进行计量。空间复杂度 ： O(n) . 如果你有更好的办法或者对我这里的描述有其他看法，请联系我。谢谢 About Me我的博客 leonchen1024.com 我的 GitHub https://github.com/LeonChen1024 微信公众号","link":"/2018/08/31/5-Longest-Palindromic-Substring/Record-cn/"},{"title":"LeetCode 6. ZigZag Conversion","text":"[English ver] 6. ZigZag ConversionThe string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)123P A H NA P L S I I GY I R And then read line by line: “PAHNAPLSIIGYIR”Write the code that will take a string and make this conversion given a number of rows:1string convert(string text, int nRows); convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”. First we need to know the meaning about the zigzag pattern, it means a pattern made up of small corners at variable angles, though constant within the zigzag, tracing a path between two parallel lines; it can be described as both jagged and fairly regular. In the begining i think it’s one line in the middle and then some symmetry verticle line between the middle horizontal line,when the number of rows is 4(use number to represent the index of the String)it would look like that: 123451 7 132 8 143 6 9 12 154 10 165 11 17 but the trueth is not , it should be looked like that:12341 7 132 6 8 12 143 5 9 11 154 10 16 Approach 1 use String[]:123456789101112131415161718192021222324252627282930313233public class Solution { public String convert(String s, int numRows) { String result = \"\"; String[] strings = new String[numRows]; for (int i =0;i&lt;numRows;i++){ strings[i] = \"\"; } int position = 0 ; int numRowsIndex = numRows-1; int step = 1; //if the numRows is one ,or the s's length is less than numRows ,return s . if (numRows ==1 || s.length()&lt;numRows){ return s; } //loop the every char in the String, when the position is 0,the step is one ,is the position is numRowsIndex,the step is negative one for (int i =0;i&lt;s.length();i++){ strings[position] += s.charAt(i); if (position ==0){ step = 1; } if (position == numRowsIndex ){ step = -1; } position = position+step; } for (int i =0;i&lt;numRows;i++){ result += strings[i]; } return result; }} AnalysisThis method put every line’s String into the String[i] accordingly,in the last concate it together and then we get the result we want . When the position is in the first row , next time the position should move down,so step = 1.When the position is in the last Row , next time the position should move up , so the step = -1. Time complexity ： O(n) 。n is the length of the string.Space complexity ： O(n) . Approach 2 StringBuilder[]:1234567891011121314151617181920212223242526272829303132public class Solution { public String convert(String s, int numRows) { StringBuilder result = new StringBuilder(\"\"); StringBuilder[] strings = new StringBuilder[numRows]; for (int i =0;i&lt;numRows;i++){ strings[i] = new StringBuilder(\"\"); } int position = 0 ; int numRowsIndex = numRows-1; int step = 1; //if the numRows is one ,or the s's length is less than numRows ,return s . if (numRows ==1 || s.length()&lt;numRows){ return s; } //loop the every char in the String, when the position is 0,the step is one ,is the position is numRowsIndex,the step is negative one for (int i =0;i&lt;s.length();i++){ strings[position].append(s.charAt(i)); if (position ==0){ step = 1; } if (position == numRowsIndex ){ step = -1; } position = position+step; } for (int i =0;i&lt;numRows;i++){ result.append(strings[i]); } return result.toString(); }} AnalysisThis method’s principle is the same as the Approach 1 , it just replace the String into StringBuilder,it has a big optimization. Time complexity ： O(n) 。n is the length of the string.Space complexity ： O(n) . Approach 3 use interval12345678910111213141516171819202122232425262728293031public class Solution { public String convert(String s, int numRows) { String result=\"\"; if(numRows==1) return s; int step1,step2; int len=s.length(); for(int i=0;i&lt;numRows;++i){ step1=(numRows-i-1)*2; step2=(i)*2; int pos=i; if(pos&lt;len) result+=s.charAt(pos); while(true){ pos+=step1; if(pos&gt;=len) break; if(step1&gt;0) result+=s.charAt(pos); pos+=step2; if(pos&gt;=len) break; if(step2&gt;0) result+=s.charAt(pos); } } return result; }} Analysis 123456789/*n=numRowsΔ=2n-2 1 2n-1 4n-3Δ= 2 2n-2 2n 4n-4 4n-2Δ= 3 2n-3 2n+1 4n-5 .Δ= . . . . .Δ= . n+2 . 3n .Δ= n-1 n+1 3n-3 3n-1 5n-5Δ=2n-2 n 3n-2 5n-4*/ This method used regular interval to calculate position . Time complexity ： O(n) 。n is the length of the string.Space complexity ： O(n) . If you have any suggestions to make the logic and implementation more better , or you have some advice on my description. Please let me know!Thanks! About MeMy blog leonchen1024.com My Github https://github.com/LeonChen1024 My twitter https://twitter.com/LChen1024?lang=en","link":"/2018/09/12/6-ZigZag-Conversion/Record-en/"},{"title":"LeetCode 5.Longest Palindromic Substring","text":"5. Longest Palindromic SubstringGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.Example:123Input: &quot;babad&quot;Output: &quot;bab&quot; Note: “aba” is also a valid answer. Example:123Input: &quot;cbbd&quot;Output: &quot;bb&quot; I have misunderstood the meaning of the word palindrome , i thought it was the meaning of repeat,finally i know that it was the meaning of a string which is the same when you look from left to right and from right to left.According to that , we know it has two situation,one the length is odd , another is even . Approach 1 :1234567891011121314151617181920212223242526public class Solution { private int lo, maxLen; public String longestPalindrome(String s) { int len = s.length(); if (len &lt; 2) return s; for (int i = 0; i &lt; len - 1; i++) { extendPalindrome(s, i, i); //assume odd length, try to extend Palindrome as possible extendPalindrome(s, i, i + 1); //assume even length. } return s.substring(lo, lo + maxLen); } private void extendPalindrome(String s, int j, int k) { while (j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k)) { j--; k++; } if (maxLen &lt; k - j - 1) { lo = j + 1; maxLen = k - j - 1; } } } AnalysisThis method divided the problem into two situation.First we loop the every char of the String,each char call the extendPalindrome method .The extendPalindrome method is used to find the char of corresponding position is the same or not . if so we move the index of the left char to left one ,and the right char to right one,and then repeat this procedure. Time complexity ： O(n^2) 。n is the length of the string.Space complexity ： O(n) . Approach 2 :12345678910111213141516171819202122232425public class Solution { public String longestPalindrome(String s) { String res = \"\"; int currLength = 0; for(int i=0;i&lt;s.length();i++){ if(isPalindrome(s,i-currLength-1,i)){ res = s.substring(i-currLength-1,i+1); currLength = currLength+2; } else if(isPalindrome(s,i-currLength,i)){ res = s.substring(i-currLength,i+1); currLength = currLength+1; } } return res; } public boolean isPalindrome(String s, int begin, int end){ if(begin&lt;0) return false; while(begin&lt;end){ if(s.charAt(begin++)!=s.charAt(end--)) return false; } return true; }} AnalysisThis method is when then index move to right , we used the char of this index as the end of the substring which length is current length +1 or current length +2, and see if is the Palindrome string . Time complexity ： O(n^2) 。n is the length of the string.Space complexity ： O(n) . Approach 3 (Manacher’s Algorithm)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class Solution { public String longestPalindrome(String s) { char[] str = changeString(s); String result = manacher(str,s); return result;}/** * 返回例如 #a#c#b#c#a#a#c#b#c#d#形式的字符串数组 * * @param s * @return */ public static char[] changeString(String s) { char[] str = new char[s.length() * 2 + 1]; int i = 0; for (; i &lt; s.length(); i++) { str[2 * i] = '#'; str[2 * i + 1] = s.charAt(i); } str[2 * i] = '#'; return str; } /** * manacher 算法实现找到回文字符串最长的一个 */ public static String manacher(char[] s,String olds) { String result = \"\"; int rad[] = new int[s.length]; int start = 0; int end = 0; //i index,j 回文半径，k int i = 1, j = 0, k; // 记录最长的回文串的长度 int maxLen = 0; while (i &lt; s.length) { // 扫描得出rad值 while (i - j - 1 &gt; -1 &amp;&amp; i + j + 1 &lt; s.length &amp;&amp; s[i - j - 1] == s[i + j + 1]) { j++; } if (maxLen &lt; j ) { maxLen =j; start = i - j ; end =i + j ; } rad[i] = j; maxLen = maxLen &gt; j ? maxLen : j; k = 1; //当回文中包含子回文，看子回文是否超出父回文边界。 分三种情况。 while (k &lt;= rad[i] &amp;&amp; rad[i - k] != rad[i] - k) { rad[i + k] = Math.min(rad[i - k], rad[i] - k); k++; } i = i + k; j = Math.max(j - k, 0); } result = olds.substring(start/2,end/2); return result; }} Analysis In this question,the Palindrome has two situation, one is even Palindrome , another is odd Palindrome. In order to combine them into one situation, we can add a special char like ‘#’ between every two char of the string which is neaby ,and the begining and the ending of the string . like “#a#b#b#c#a#”. Now we have combine the two situation into together. In the String s ,we use rad[i] to represent the Palindrome radius of index i , we can get s[i-rad[i],i-1] = s[i+1,i+rad[i]] easily , once we get the all the rad of the String , we get the all the Palindrome which is even length . when we get the value of rad[1..i-1],and get the rad value of the char i is at least j through compare char which is symmetry.Now we suppose that we have a index k , it start from 1 to rad[i],we can use it to get the rad valule of the [i+1,i+rad[i]]. According to the acept of the Palindrome , we know the part of the black is a Palindrome, two parts of the red have the same length.Because we have calculate the value of rad[i-k],so we can use it . There are three situations:(1)rad[i]-k &lt; rad[i-k] As the picture , rad[i-k]’s range is blackish green line . Because of the black line is Palindrome,and a part of blackish green line is out of the black line,so rad[i+k] is at least rad[i]-k (the orange line).Is there have any possible that rad[i+k] is larger than rad[i]-k? it’s impossible ,according to the acept of the Palindrome ,we know that if the part out of the orange line is the Palindrome , than the black line can expand outward. Is different from the suppose we have done . so rad[i+k] = rad[i]-k。 （2）rad[i]-k &gt; rad[i-k] As the picture , rad[i-k]’s range is the blackish green line . Because the black line is Palindrome and the blackish green line is in the black line , according to the acept of the Palindrome ,we can get that rad[i+k] = rad[i-k] easily. According to the situation we have talk , we can get that when rad[i]-k != rad[i-k] ,rad[i+k] = min(rad[i]-k,rad[i-k])。 （3）rad[i]-k = rad[i-k] As the picture , after compare to the first situation , we can find that because the blackish line is in the black line , so even the orange line is equals , it can’t cause a contradiction like situation 1 ,so the orange line can be equals . But , according to the message we know , we have not idear how long is the orange line , so we put the i to the i+k position , j=rad[i-k](because it’s rad is at least rad[i-k]), wait to next loop to calculate it can expand out or not . Time complexity ： O(n) 。it looks like the program is use the nesting loop ,but actualy it only calculate the i which haven’t calculated.Space complexity ： O(n) . If you have any suggestions to make the logic and implementation more better , or you have some advice on my description. Please let me know!Thanks! About MeMy blog leonchen1024.com My Github https://github.com/LeonChen1024 My twitter https://twitter.com/LChen1024?lang=en","link":"/2018/08/31/5-Longest-Palindromic-Substring/Record-en/"},{"title":"LeetCode 7. 数字反转","text":"[Chinese ver] 7. Reverse Integer颠倒一个 integer 的前后位数。 例子: x = 123, return 321例子: x = -123, return -321 注意：输入是一个32位的有符号 integer . 当颠倒的 interger 溢出的时候你的函数应该返回0。 提示 你是否注意到了这些？在你编程之前你应该先想想这些问题。如果你已经考虑到了这些那是很加分的！ 如果 integer 的最后一位是0，应该输出什么？比如，10，100. 你是否注意到了颠倒的 integer 可能会溢出？假设输入是一个 32位的 integer ，那么1000000003的颠倒溢出了。你该怎么处理这种情况？ 为了解决这个问题，假设你的函数当颠倒的 integer 溢出的话返回0. 方法一 使用StringBuilder：1234567891011121314151617181920212223242526272829303132public class Solution { public int reverse(int x) { //judge x is negative or not boolean isNegative = false; int result =0; if (x&lt;0){ isNegative = true; x = Math.abs(x); } StringBuilder oldSB = new StringBuilder(String.valueOf(x)); StringBuilder newSB = new StringBuilder(); //reverse the x use StringBuilder for (int i = 0;i &lt; oldSB.length() ; i++){ newSB.append(oldSB.charAt(oldSB.length()-i-1)); } try{ result = Integer.valueOf(newSB.toString()); } catch(Exception e){ //if overflows return the result 0 return result; } if (isNegative){ result = -result; } return result; } } 分析这个方法使用StringBuilder 将 Integer 转换成正数进行颠倒的操作，使用 try catch 来处理溢出的情况。如果输入是负数，最后的结果在转为负数。时间复杂度 ： O(n) 。n是输入的位数空间复杂度 ： O(1) . 方法二 使用int：12345678910111213141516171819202122public class Solution1 { public int reverse(int x) { int result = 0; while (x != 0) { //get the last digit of the x. int tail = x % 10; //add a digit in the end of the newResult ,and update the newResult's last digit int newResult = result * 10 + tail; //judge if newResult is overflows if ((newResult - tail) / 10 != result) { return 0; } result = newResult; //remove the last digit of x x = x / 10; } return result; }} 或者 123456789101112131415public class Solution2 { public int reverse(int x) { long rev= 0; while( x != 0){ //add a digit in the end of the newResult ,and update the newResult's last digit rev= rev*10 + x % 10; //remove the last digit of x x= x/10; //judge if newResult is overflows if( rev &gt; Integer.MAX_VALUE || rev &lt; Integer.MIN_VALUE) return 0; } return (int) rev; }} 分析这两个方法的原理都是一样的，通过将输入的x%10取余数得到最后一位数的值，然后使用 result*10 将result 增加一位并将最后一位更新为余数值，然后更新x为x/10。这两个方法不同的地方是判断溢出的方法，Solution1 在更新 result 之后将新的 result 去掉最后一位和旧的 result 进行比较，看是否一致来判断是否溢出。Solution2 则是将新的 result 和 Integer 的临界值进行比较来判断是否溢出，要注意的是 Solution2 里的 long rev= 0; 一定不能使用 Integer ，因为一旦 Integer 溢出了 rev 就会被自动处理溢出，所以 rev &gt; Integer.MAX_VALUE || rev &lt; Integer.MIN_VALUE 永远不会为true。 时间复杂度 ： O(n) 。n是输入的位数空间复杂度 ： O(1) . 如果你有更好的办法或者对我这里的描述有其他看法，请联系我。谢谢 About Me我的博客 leonchen1024.com 我的 GitHub https://github.com/LeonChen1024 微信公众号","link":"/2018/12/02/7-Reverse-Integer/Record-cn/"},{"title":"LeetCode 7. Reverse Integer","text":"[English ver]Easy 7. Reverse IntegerReverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 Note:The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. spoilers Have you thought about this?Here are some good questions to ask before coding. Bonus points for you if you have already thought through this! If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100. Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases? For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Approach 1 use StringBuilder:1234567891011121314151617181920212223242526272829303132public class Solution { public int reverse(int x) { //judge x is negative or not boolean isNegative = false; int result =0; if (x&lt;0){ isNegative = true; x = Math.abs(x); } StringBuilder oldSB = new StringBuilder(String.valueOf(x)); StringBuilder newSB = new StringBuilder(); //reverse the x use StringBuilder for (int i = 0;i &lt; oldSB.length() ; i++){ newSB.append(oldSB.charAt(oldSB.length()-i-1)); } try{ result = Integer.valueOf(newSB.toString()); } catch(Exception e){ //if overflows return the result 0 return result; } if (isNegative){ result = -result; } return result; } } AnalysisThis approach turn Integer to a positive Integer and reverse it with StringBuilder. use try catch to deal with the overflows . if the input is negative , we can change the result to negative in last. Time complexity ： O(n) 。n is the digit of the xSpace complexity ： O(1) . Approach 2 use int:12345678910111213141516171819202122public class Solution1 { public int reverse(int x) { int result = 0; while (x != 0) { //get the last digit of the x. int tail = x % 10; //add a digit in the end of the newResult ,and update the newResult's last digit int newResult = result * 10 + tail; //judge if newResult is overflows if ((newResult - tail) / 10 != result) { return 0; } result = newResult; //remove the last digit of x x = x / 10; } return result; }} or 123456789101112131415public class Solution2 { public int reverse(int x) { long rev= 0; while( x != 0){ //add a digit in the end of the newResult ,and update the newResult's last digit rev= rev*10 + x % 10; //remove the last digit of x x= x/10; //judge if newResult is overflows if( rev &gt; Integer.MAX_VALUE || rev &lt; Integer.MIN_VALUE) return 0; } return (int) rev; }} AnalysisThese two Solution has the same principle . They use the input x%10 to get the remainder which is the last digit of the x, and then use result*10 to add a digit to result and update the last digit to the x%10 , after that update x to x/10.The only difference of the two solution is the way to judge the result is overflows or not. Solution1 is use the new result remove last digit campare to the old result,if they are equals to each other there is not overflows,else there is overflows. In other side , Solution2 is use the new result compare to the Integer’s limit threshold ,if it didn’t out of the threshold ,there is not overflows,else there is a overflows, notice that , long rev = 0; in the code,your can;t use Integer to replace it , because once Integer overflows,java will change the value to make it between the limit threshold of the Integer. So rev &gt; Integer.MAX_VALUE || rev &lt; Integer.MIN_VALUE will never be true. Time complexity ： O(n) 。n is the digit of the x.Space complexity ： O(1) . If you have any suggestions to make the logic and implementation more better , or you have some advice on my description. Please let me know!Thanks! About MeMy blog leonchen1024.com My Github https://github.com/LeonChen1024 My twitter https://twitter.com/LChen1024?lang=en","link":"/2018/12/02/7-Reverse-Integer/Record-en/"},{"title":"LeetCode 8. String to Integer (atoi)","text":"[English ver] 8. String to Integer (atoi)Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Update (2015-02-10):The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. Requirements for atoi:The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. Approach 1:12345678910111213141516171819202122232425262728293031323334353637383940414243public class Solution { public int myAtoi(String str) { int index = 0 , sign = 1 ; long result = 0 ; //if str is a empty string or null if (str.equals(null)||str.length()==0 ){ return 0; } //remove the ' ' in the front while (str.charAt(index)==' '&amp;&amp;index &lt; str.length()){ index++; } //take the sign if(str.charAt(index)=='+'||str.charAt(index)=='-'){ sign = str.charAt(index)=='+' ? 1 : -1; index ++; } //convert number and avoid overflows while (index &lt; str.length()){ if(str.charAt(index)&lt;='9'&amp;&amp;str.charAt(index)&gt;='0'){ int current = str.charAt(index)-'0'; result = result * 10 + current; // check if the str is overflows if(result&gt;Integer.MAX_VALUE&amp;&amp;sign==1){ return Integer.MAX_VALUE; }else if(-result&lt;Integer.MIN_VALUE&amp;&amp;sign==-1){ return Integer.MIN_VALUE; } index++; }else { break; } } return sign*((int)result); }} or 12345678910111213141516171819202122232425262728293031public class Solution2 { public int myAtoi(String str) { int index = 0, sign = 1, total = 0; //1. Empty string if(str.length() == 0) return 0; //2. Remove Spaces while(str.charAt(index) == ' ' &amp;&amp; index &lt; str.length()) index ++; //3. Handle signs if(str.charAt(index) == '+' || str.charAt(index) == '-'){ sign = str.charAt(index) == '+' ? 1 : -1; index ++; } //4. Convert number and avoid overflow while(index &lt; str.length()){ int digit = str.charAt(index) - '0'; if(digit &lt; 0 || digit &gt; 9) break; //check if total will be overflow after 10 times and add digit if(Integer.MAX_VALUE/10 &lt; total || Integer.MAX_VALUE/10 == total &amp;&amp; Integer.MAX_VALUE %10 &lt; digit) return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; total = 10 * total + digit; index ++; } return total * sign;}} /Images/OneResult.png?raw=true) Analysis The principle of these two method are similar ,except the judgement of the overflows ,first method use the long value compare to the Integer’s limit value , the another one use Int value , notice that it can’t be compare to the Integer’s limit value , because the int value will be changed if it overflows , it id never be out of the Integer’s range , so it use the int value of the last time you get to campare with the Max/10 ,and then use the value you want to connect to the value you get last time to campare with the Max%10 . Time complexity ： O(n) 。n is the digit of the xSpace complexity ： O(1) . If you have any suggestions to make the logic and implementation more better , or you have some advice on my description. Please let me know!Thanks! About MeMy blog leonchen1024.com My Github https://github.com/LeonChen1024 My twitter https://twitter.com/LChen1024?lang=en","link":"/2019/01/20/LeetCode-8-String-to-Integer/Record-en/"},{"title":"LeetCode 8. 字符串转整数","text":"[Chinese ver] 8. 字符串转整数 (atoi)[TOC] 实现一个 atoi 方法来将一个 string 转换成一个 integer. 提示：仔细的思考所有可能的输入情况。如果你想要一个挑战，请不要看以下内容并问你自己什么是可能的输入情况。 注意：模糊的指定输入范围就是这个题目的目的(比如没有给输入规范)。你负责收集前面所有的输入要求。 atoi 的要求：函数首先丢弃所有首个非空格字符之前的所有空格。然后从这个字符开始，得到一个初始化的加号或减号开始的尽可能多的位数，然后将他们转换成数字值。 这个字符串在数字形式的子字符串后可以有其他的字符，这些字符将会被忽略而且不会对这个方法有影响。 如果第一个非空格的字符序列不是一个合法的整数，或者如果并没有符合要求的序列比如字符串是空的或者它只包含了空格字符，不执行转化。 如果不能执行转换，返回0.如果正确值超出了可以描述的值范围，返回 INT_MAX (2147483647) 或者 INT_MIN (-2147483648). 方法一 :12345678910111213141516171819202122232425262728293031323334353637383940414243public class Solution { public int myAtoi(String str) { int index = 0 , sign = 1 ; long result = 0 ; //if str is a empty string or null if (str.equals(null)||str.length()==0 ){ return 0; } //remove the ' ' in the front while (str.charAt(index)==' '&amp;&amp;index &lt; str.length()){ index++; } //take the sign if(str.charAt(index)=='+'||str.charAt(index)=='-'){ sign = str.charAt(index)=='+' ? 1 : -1; index ++; } //convert number and avoid overflows while (index &lt; str.length()){ if(str.charAt(index)&lt;='9'&amp;&amp;str.charAt(index)&gt;='0'){ int current = str.charAt(index)-'0'; result = result * 10 + current; // check if the str is overflows if(result&gt;Integer.MAX_VALUE&amp;&amp;sign==1){ return Integer.MAX_VALUE; }else if(-result&lt;Integer.MIN_VALUE&amp;&amp;sign==-1){ return Integer.MIN_VALUE; } index++; }else { break; } } return sign*((int)result); }} 或者 12345678910111213141516171819202122232425262728293031public class Solution2 { public int myAtoi(String str) { int index = 0, sign = 1, total = 0; //1. Empty string if(str.length() == 0) return 0; //2. Remove Spaces while(str.charAt(index) == ' ' &amp;&amp; index &lt; str.length()) index ++; //3. Handle signs if(str.charAt(index) == '+' || str.charAt(index) == '-'){ sign = str.charAt(index) == '+' ? 1 : -1; index ++; } //4. Convert number and avoid overflow while(index &lt; str.length()){ int digit = str.charAt(index) - '0'; if(digit &lt; 0 || digit &gt; 9) break; //check if total will be overflow after 10 times and add digit if(Integer.MAX_VALUE/10 &lt; total || Integer.MAX_VALUE/10 == total &amp;&amp; Integer.MAX_VALUE %10 &lt; digit) return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; total = 10 * total + digit; index ++; } return total * sign;}} /Images/OneResult.png?raw=true) 分析这两段代码的原理是大致相同的，主要区别就是判断溢出的方式，第一个使用的 long 和 Integer 的区间进行比较来判断是否溢出；第二个使用的是 Int ，但是不能直接和 Integer 的区间进行比较，因为Int 的数据一旦溢出会被处理掉，不会出现区间外的值，所以是将前一次得到的 Int 值和 Max／10 比较，然后将这次取得的数值和 Max%10进行比较 时间复杂度 ： O(n) 。n是输入的位数空间复杂度 ： O(1) . 如果你有更好的办法或者对我这里的描述有其他看法，请联系我。谢谢 About Me我的博客 leonchen1024.com 我的 GitHub https://github.com/LeonChen1024 微信公众号","link":"/2019/01/20/LeetCode-8-String-to-Integer/Record-cn/"}],"tags":[{"name":"Chinese","slug":"Chinese","link":"/tags/Chinese/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"版本管理","slug":"版本管理","link":"/tags/版本管理/"},{"name":"版本差异","slug":"版本差异","link":"/tags/版本差异/"},{"name":"Error","slug":"Error","link":"/tags/Error/"},{"name":"UI","slug":"UI","link":"/tags/UI/"},{"name":"Custom View","slug":"Custom-View","link":"/tags/Custom-View/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Data Structure","slug":"Data-Structure","link":"/tags/Data-Structure/"},{"name":"DataStructure","slug":"DataStructure","link":"/tags/DataStructure/"},{"name":"Optimize","slug":"Optimize","link":"/tags/Optimize/"},{"name":"SourceCode","slug":"SourceCode","link":"/tags/SourceCode/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"}],"categories":[{"name":"Chinese","slug":"Chinese","link":"/categories/Chinese/"},{"name":"Android","slug":"Chinese/Android","link":"/categories/Chinese/Android/"},{"name":"Algorithm","slug":"Chinese/Algorithm","link":"/categories/Chinese/Algorithm/"},{"name":"Java","slug":"Chinese/Java","link":"/categories/Chinese/Java/"},{"name":"DataStructure","slug":"Chinese/DataStructure","link":"/categories/Chinese/DataStructure/"},{"name":"Algorithm","slug":"Chinese/Android/Algorithm","link":"/categories/Chinese/Android/Algorithm/"},{"name":"Error","slug":"Chinese/Android/Error","link":"/categories/Chinese/Android/Error/"},{"name":"版本管理","slug":"Chinese/Android/版本管理","link":"/categories/Chinese/Android/版本管理/"},{"name":"UI","slug":"Chinese/Android/UI","link":"/categories/Chinese/Android/UI/"},{"name":"Common","slug":"Chinese/Algorithm/Common","link":"/categories/Chinese/Algorithm/Common/"},{"name":"版本差异","slug":"Chinese/Android/版本差异","link":"/categories/Chinese/Android/版本差异/"},{"name":"Data Structure","slug":"Chinese/Java/Data-Structure","link":"/categories/Chinese/Java/Data-Structure/"},{"name":"Common","slug":"Chinese/DataStructure/Common","link":"/categories/Chinese/DataStructure/Common/"},{"name":"SourceCode","slug":"Chinese/Java/SourceCode","link":"/categories/Chinese/Java/SourceCode/"},{"name":"Custom View","slug":"Chinese/Android/UI/Custom-View","link":"/categories/Chinese/Android/UI/Custom-View/"},{"name":"English","slug":"English","link":"/categories/English/"},{"name":"LeetCode","slug":"Chinese/Algorithm/LeetCode","link":"/categories/Chinese/Algorithm/LeetCode/"},{"name":"Algorithm","slug":"English/Algorithm","link":"/categories/English/Algorithm/"},{"name":"LeetCode","slug":"English/Algorithm/LeetCode","link":"/categories/English/Algorithm/LeetCode/"}]}