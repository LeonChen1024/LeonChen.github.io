{"meta":{"title":"LeonChen's Blog","subtitle":null,"description":null,"author":"LeonChen","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-03-11T13:24:26.000Z","updated":"2018-03-11T13:36:27.196Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"about","date":"2018-03-11T13:24:38.000Z","updated":"2018-03-11T13:24:38.958Z","comments":true,"path":"about/index-1.html","permalink":"http://yoursite.com/about/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2018-03-11T04:11:35.000Z","updated":"2018-03-11T04:18:23.561Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-03-11T04:11:41.000Z","updated":"2018-03-11T04:19:15.835Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"APP 版本控制","slug":"APP-Version-Control","date":"2018-04-12T16:00:00.000Z","updated":"2018-04-14T07:53:59.801Z","comments":true,"path":"2018/04/13/APP-Version-Control/","link":"","permalink":"http://yoursite.com/2018/04/13/APP-Version-Control/","excerpt":"","text":"版本管理是app的一个重要部分，他主要的用途有： 让用户了解当前的版本信息，了解升级或者降级信息等 不同的版本可能提供的服务和功能有所差别，版本信息可以给我们一个标志来识别当前版本可提供的服务和功能。 设置版本信息官方推荐是在Gradle中进行版本设置，因为Gradle中设置的版本信息会在构建的时候合并到manifest文件中，并会替换掉manifest中有关版本信息的设置。并且在Gradle中进行设置的话还可以根据应用不同的Flavor进行不同的设置。 版本控制主要有这么两个属性： -versionCode ： 整数，是内部版本号，仅用于判断一个版本是否比另一个版本新，用户并不会看到。通常是跟随着发布版本增加该code。 -versionName : 字符串，用户能看到的版本号。 通常我们将这些设置放在gradle下的android {} 块内部使用defaultConfig {} 包裹它。要注意，如果你在productFlavors中定义了这些属性，他们会覆盖defaultConfig中的值。 1234567891011121314151617android &#123; ... defaultConfig &#123; ... versionCode 1 versionName &quot;1.0.0&quot; &#125; productFlavors &#123; a &#123; ... versionName &quot;1.0.0&quot; &#125; b &#123; ... &#125; &#125;&#125; 在android中使用 PackageManager 的 getPackageInfo(java.lang.String, int) 方法可以获取版本信息。 1234567891011public static String getVersion(Context context)//获取版本号 &#123; try &#123; PackageInfo pi=context.getPackageManager().getPackageInfo(context.getPackageName(), 0); return pi.versionName; &#125; catch (NameNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return context.getString(R.string.version_unknown); &#125; &#125; 1234567891011public static int getVersionCode(Context context)//获取版本号(内部识别号)&#123; try &#123; PackageInfo pi=context.getPackageManager().getPackageInfo(context.getPackageName(), 0); return pi.versionCode; &#125; catch (NameNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return 0; &#125;&#125; 如果使用 Instant Run，Android Studio 会自动将 versionCode 设置为 MAXINT，将 versionName 设置为 INSTANTRUN。 统一配置顺便说一下一个可以统一所有的配置在一个地方的方法，这样可以便于我们管理版本。首先在主工程的build.gradle里增加一个配置区 12345678910ext &#123; // Sdk and tools minSdkVersion = 17 targetSdkVersion = 21 compileSdkVersion = 23 buildToolsVersion = &quot;23.0.3&quot; // App dependencies supportLibraryVersion = &apos;23.3.0&apos;&#125; 然后在module的build.gradle里使用123targetSdkVersion rootProject.ext.targetSdkVersioncompile &quot;com.android.support:appcompat-v7:$rootProject.supportLibraryVersion&quot; 123456789101112/** * 判断当前应用是否是debug状态 */public static boolean isApkInDebug(Context context) &#123; try &#123; ApplicationInfo info = context.getApplicationInfo(); return (info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0; &#125; catch (Exception e) &#123; return false; &#125;&#125; 1234567891011121314151617/***检测其他应用是否处于debug模式。*/public static boolean isApkDebugable(Context context,String packageName) &#123; try &#123; PackageInfo pkginfo = context.getPackageManager().getPackageInfo( packageName, 1); if (pkginfo != null ) &#123; ApplicationInfo info= pkginfo.applicationInfo; return (info.flags&amp;ApplicationInfo.FLAG_DEBUGGABLE)!=0; &#125; &#125; catch (Exception e) &#123; &#125; return false; &#125; Referencehttps://developer.android.com/studio/publish/versioning.html","categories":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/categories/Chinese/"},{"name":"Android","slug":"Chinese/Android","permalink":"http://yoursite.com/categories/Chinese/Android/"},{"name":"版本管理","slug":"Chinese/Android/版本管理","permalink":"http://yoursite.com/categories/Chinese/Android/版本管理/"}],"tags":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/tags/Chinese/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"版本管理","slug":"版本管理","permalink":"http://yoursite.com/tags/版本管理/"}]},{"title":"Android 相关错误及解决办法","slug":"Android-Error-And-Solution","date":"2018-01-10T14:15:10.000Z","updated":"2018-04-14T06:59:32.407Z","comments":true,"path":"2018/01/10/Android-Error-And-Solution/","link":"","permalink":"http://yoursite.com/2018/01/10/Android-Error-And-Solution/","excerpt":"","text":"问题 : Unable to instantiate activity ComponentInfo{com.xxxx.xxxx/com.xxxx.xxxx.LoginActivity}java.lang.RuntimeException: Unable to instantiate activity ComponentInfo{com.xxxx.xxxx/com.xxxx.xxxx.LoginActivity}: java.lang.ClassNotFoundException: Didn’t find class “com.xxxx.xxxx.LoginActivity” on path: /data/app/com.xxxx.xxxx-1. 解决方法 : 原因AndroidManifest.xml文件出错。将问题Activity的name具体到某个包下即可运行。android:name=”.LogoActivity”改为android:name=”.ac.LogoActivity”.","categories":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/categories/Chinese/"},{"name":"Android","slug":"Chinese/Android","permalink":"http://yoursite.com/categories/Chinese/Android/"},{"name":"Error","slug":"Chinese/Android/Error","permalink":"http://yoursite.com/categories/Chinese/Android/Error/"}],"tags":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/tags/Chinese/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Error","slug":"Error","permalink":"http://yoursite.com/tags/Error/"}]}]}