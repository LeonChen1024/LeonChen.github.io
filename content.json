{"meta":{"title":"LeonChen's Blog","subtitle":null,"description":null,"author":"LeonChen","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-03-11T04:11:35.000Z","updated":"2018-03-11T04:18:23.561Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-03-11T04:11:41.000Z","updated":"2018-03-11T04:19:15.835Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2018-03-11T13:24:38.000Z","updated":"2018-03-11T13:24:38.958Z","comments":true,"path":"about/index-1.html","permalink":"http://yoursite.com/about/index-1.html","excerpt":"","text":""},{"title":"about","date":"2018-03-11T13:24:26.000Z","updated":"2018-03-11T13:36:27.196Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode 2. Add Two Numbers [English ver]","slug":"2-Add-Two-Num/Record[English-ver]","date":"2018-07-14T16:00:00.000Z","updated":"2018-07-15T00:12:28.553Z","comments":true,"path":"2018/07/15/2-Add-Two-Num/Record[English-ver]/","link":"","permalink":"http://yoursite.com/2018/07/15/2-Add-Two-Num/Record[English-ver]/","excerpt":"","text":"[English ver] 2. Add Two NumbersQuestion ：You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Approach 1：12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125; AnalysisActually, the problem is easy to resolved if you are familiar with the use of the list and the logic of the arithmetic . Plus every bit base on decimal, note that the addition of the carry will only be 0 or 1, because even if you use the two largest number 9 +9 in finally you only get carry 1, then use the largest number 9 +9 + 1 will only Get 19, the carry is 1 too. So the main logic is (the sum of two numbers )sum / 10 is the carry, sum% 10 is the number of the this bit . DummyHead is a fake data header, used to do an initialization, it is possible if you don’t want to use it, but in the internal logic you need to deal with the difference logic between the first bit of the result and the number of subsequent .Note that there are several special cases. 1. The length of one list is longer than the other. 2. One of the lists is empty. 3. There is still have a carry in the last bit Time complexity: O (max (m, n)). The total number of cycles is the largest number between m and n.Space complexity: O (max (m, n)). The length of the new list we create is the maximum length of m, n, plus a dummy header. Approach 212345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode ln1 = l1, ln2 = l2, head = null, node = null; int carry = 0, remainder = 0, sum = 0; head = node = new ListNode(0); while(ln1 != null || ln2 != null || carry != 0) &#123; sum = (ln1 != null ? ln1.val : 0) + (ln2 != null ? ln2.val : 0) + carry; carry = sum / 10; remainder = sum % 10; node = node.next = new ListNode(remainder); ln1 = (ln1 != null ? ln1.next : null); ln2 = (ln2 != null ? ln2.next : null); &#125; return head.next; &#125;&#125; This is someone else’s approach, actually these two methods in the overall thinking is almost the same ,but this approach is more faster than approach 1 . why ? I think the approach 1 is always create a int x,y and other objects in the cycle , because the timing was based on thousands of examples , result a gap about 20ms. This is purely personal think , if you have more correct ideas, or somewhere is an argument about the reason this gap, please tell me. Thank you. About MeMy blog leonchen1024.com My Github [https://github.com/LeonChen1024","categories":[{"name":"English","slug":"English","permalink":"http://yoursite.com/categories/English/"},{"name":"Algorithm","slug":"English/Algorithm","permalink":"http://yoursite.com/categories/English/Algorithm/"},{"name":"LeetCode","slug":"English/Algorithm/LeetCode","permalink":"http://yoursite.com/categories/English/Algorithm/LeetCode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"English","slug":"English","permalink":"http://yoursite.com/tags/English/"}]},{"title":"LeetCode 2. Add Two Numbers [Chinese ver]","slug":"2-Add-Two-Num/Record[Chinese-ver]","date":"2018-07-14T16:00:00.000Z","updated":"2018-07-15T00:11:36.497Z","comments":true,"path":"2018/07/15/2-Add-Two-Num/Record[Chinese-ver]/","link":"","permalink":"http://yoursite.com/2018/07/15/2-Add-Two-Num/Record[Chinese-ver]/","excerpt":"","text":"[Chinese ver] 2. Add Two Numbers问题：你将获得两个非空 linked lists来表示两个非负整数。 数字以反向的顺序存储，并且它们的每个节点包含一位数字。 将两个数字相加并将其以 linked list的形式返回。 你可以假定这两个数字不包含任何前导零（即不存在首位出现0的情况），除了数字0本身。 输入 ：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出 ： 7 -&gt; 0 -&gt; 8 方法一：12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125; 分析其实这个问题熟悉一下链表的使用和算术的逻辑就可以解决了。按位加过十进一，注意，加法的进位只会是0或者1，因为就算你用两个最大的数9+9最后也只是进一，进一之后再9+9+1也只会得到19，还是进一。所以主要的逻辑就是两个数的和sum/10得到的是进位，sum%10得到的是本位的数。dummyHead是一个假的数据头，用来做一个初始化，不使用也是可以的，但是在内部逻辑中就需要自己在处理第一位和后续的位数的逻辑区别。注意有几种特殊情况。1.其中一个list的长度比另一个要长。2.其中一个list为空。3.加到最后一位时仍然还有进位 时间复杂度： O(max(m,n)).总共循环m和n中的最大次数。空间复杂度 : O(max(m,n)).我们得到的新的list 的长度是m,n中最大长度，加上一个假数据头。 方法二12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode ln1 = l1, ln2 = l2, head = null, node = null; int carry = 0, remainder = 0, sum = 0; head = node = new ListNode(0); while(ln1 != null || ln2 != null || carry != 0) &#123; sum = (ln1 != null ? ln1.val : 0) + (ln2 != null ? ln2.val : 0) + carry; carry = sum / 10; remainder = sum % 10; node = node.next = new ListNode(remainder); ln1 = (ln1 != null ? ln1.next : null); ln2 = (ln2 != null ? ln2.next : null); &#125; return head.next; &#125;&#125; 这个是别人的做法，居然能够比方法一快了许多，说实话，其实这两个方法在整体思路上是差不多的，至于为什么会比前者快那么多我觉的是方法一在循环中不断新建了x,y等对象，由于计时时用了成千上百的例子验证所以导致了20ms左右的差距。以上纯属个人看法，如果你有更正确的想法，或者哪里有有关这种差距的论证，请告诉我。谢谢。 About Me我的博客 leonchen1024.com 我的 GitHub https://github.com/LeonChen1024 微信公众号","categories":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/categories/Chinese/"},{"name":"Algorithm","slug":"Chinese/Algorithm","permalink":"http://yoursite.com/categories/Chinese/Algorithm/"},{"name":"LeetCode","slug":"Chinese/Algorithm/LeetCode","permalink":"http://yoursite.com/categories/Chinese/Algorithm/LeetCode/"}],"tags":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/tags/Chinese/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"APP 版本控制","slug":"APP-Version-Control","date":"2018-04-12T16:00:00.000Z","updated":"2018-05-18T13:47:24.034Z","comments":true,"path":"2018/04/13/APP-Version-Control/","link":"","permalink":"http://yoursite.com/2018/04/13/APP-Version-Control/","excerpt":"","text":"版本管理是app的一个重要部分，他主要的用途有： 让用户了解当前的版本信息，了解升级或者降级信息等 不同的版本可能提供的服务和功能有所差别，版本信息可以给我们一个标志来识别当前版本可提供的服务和功能。 目录 设置版本信息 统一配置 Reference 设置版本信息官方推荐是在Gradle中进行版本设置，因为Gradle中设置的版本信息会在构建的时候合并到manifest文件中，并会替换掉manifest中有关版本信息的设置。并且在Gradle中进行设置的话还可以根据应用不同的Flavor进行不同的设置。 版本控制主要有这么两个属性： -versionCode ： 整数，是内部版本号，仅用于判断一个版本是否比另一个版本新，用户并不会看到。通常是跟随着发布版本增加该code。 -versionName : 字符串，用户能看到的版本号。 通常我们将这些设置放在gradle下的android {} 块内部使用defaultConfig {} 包裹它。要注意，如果你在productFlavors中定义了这些属性，他们会覆盖defaultConfig中的值。 1234567891011121314151617android &#123; ... defaultConfig &#123; ... versionCode 1 versionName &quot;1.0.0&quot; &#125; productFlavors &#123; a &#123; ... versionName &quot;1.0.0&quot; &#125; b &#123; ... &#125; &#125;&#125; 在android中使用 PackageManager 的 getPackageInfo(java.lang.String, int) 方法可以获取版本信息。 1234567891011public static String getVersion(Context context)//获取版本号 &#123; try &#123; PackageInfo pi=context.getPackageManager().getPackageInfo(context.getPackageName(), 0); return pi.versionName; &#125; catch (NameNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return context.getString(R.string.version_unknown); &#125; &#125; 1234567891011public static int getVersionCode(Context context)//获取版本号(内部识别号)&#123; try &#123; PackageInfo pi=context.getPackageManager().getPackageInfo(context.getPackageName(), 0); return pi.versionCode; &#125; catch (NameNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return 0; &#125;&#125; 如果使用 Instant Run，Android Studio 会自动将 versionCode 设置为 MAXINT，将 versionName 设置为 INSTANTRUN。 统一配置顺便说一下一个可以统一所有的配置在一个地方的方法，这样可以便于我们管理版本。首先在主工程的build.gradle里增加一个配置区 12345678910ext &#123; // Sdk and tools minSdkVersion = 17 targetSdkVersion = 21 compileSdkVersion = 23 buildToolsVersion = &quot;23.0.3&quot; // App dependencies supportLibraryVersion = &apos;23.3.0&apos;&#125; 然后在module的build.gradle里使用123targetSdkVersion rootProject.ext.targetSdkVersioncompile &quot;com.android.support:appcompat-v7:$rootProject.supportLibraryVersion&quot; 123456789101112/** * 判断当前应用是否是debug状态 */public static boolean isApkInDebug(Context context) &#123; try &#123; ApplicationInfo info = context.getApplicationInfo(); return (info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0; &#125; catch (Exception e) &#123; return false; &#125;&#125; 1234567891011121314151617/***检测其他应用是否处于debug模式。*/public static boolean isApkDebugable(Context context,String packageName) &#123; try &#123; PackageInfo pkginfo = context.getPackageManager().getPackageInfo( packageName, 1); if (pkginfo != null ) &#123; ApplicationInfo info= pkginfo.applicationInfo; return (info.flags&amp;ApplicationInfo.FLAG_DEBUGGABLE)!=0; &#125; &#125; catch (Exception e) &#123; &#125; return false; &#125; Referencehttps://developer.android.com/studio/publish/versioning.html","categories":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/categories/Chinese/"},{"name":"Android","slug":"Chinese/Android","permalink":"http://yoursite.com/categories/Chinese/Android/"},{"name":"版本管理","slug":"Chinese/Android/版本管理","permalink":"http://yoursite.com/categories/Chinese/Android/版本管理/"}],"tags":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/tags/Chinese/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"版本管理","slug":"版本管理","permalink":"http://yoursite.com/tags/版本管理/"}]},{"title":"Android 相关错误及解决办法","slug":"Android-Error-And-Solution","date":"2018-01-10T14:15:10.000Z","updated":"2018-05-18T14:12:20.942Z","comments":true,"path":"2018/01/10/Android-Error-And-Solution/","link":"","permalink":"http://yoursite.com/2018/01/10/Android-Error-And-Solution/","excerpt":"","text":"目录 目录 问题 : Unable to instantiate activity ComponentInfo{com.xxxx.xxxx/com.xxxx.xxxx.LoginActivity} 问题 : Unable to instantiate activity ComponentInfo{com.xxxx.xxxx/com.xxxx.xxxx.LoginActivity}java.lang.RuntimeException: Unable to instantiate activity ComponentInfo{com.xxxx.xxxx/com.xxxx.xxxx.LoginActivity}: java.lang.ClassNotFoundException: Didn’t find class “com.xxxx.xxxx.LoginActivity” on path: /data/app/com.xxxx.xxxx-1. 解决方法 : 原因AndroidManifest.xml文件出错。将问题Activity的name具体到某个包下即可运行。android:name=”.LogoActivity”改为android:name=”.ac.LogoActivity”.","categories":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/categories/Chinese/"},{"name":"Android","slug":"Chinese/Android","permalink":"http://yoursite.com/categories/Chinese/Android/"},{"name":"Error","slug":"Chinese/Android/Error","permalink":"http://yoursite.com/categories/Chinese/Android/Error/"}],"tags":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/tags/Chinese/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Error","slug":"Error","permalink":"http://yoursite.com/tags/Error/"}]},{"title":"LeetCode 1 Two Sum [Chinese ver]","slug":"1-Two-Sum/Record[Chinese ver]","date":"2017-02-16T16:00:00.000Z","updated":"2018-07-04T13:51:35.951Z","comments":true,"path":"2017/02/17/1-Two-Sum/Record[Chinese ver]/","link":"","permalink":"http://yoursite.com/2017/02/17/1-Two-Sum/Record[Chinese ver]/","excerpt":"[Chinese ver]1 Two SumQuestion两数求和 。给定一个整数的数组，返回两个数字的索引使得这两个数字加起来成为一个指定的目标值。你可以假设每个输入都至少有一个解决方案，并且你不能使用相同的元素两次。","text":"[Chinese ver]1 Two SumQuestion两数求和 。给定一个整数的数组，返回两个数字的索引使得这两个数字加起来成为一个指定的目标值。你可以假设每个输入都至少有一个解决方案，并且你不能使用相同的元素两次。 Example:123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 首先是一次错误的尝试1234567891011121314151617181920public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] testNums = new int[nums.length]; int j = 0; for (int i=0;i&lt;nums.length;i++)&#123; if(nums[i]&lt;target)&#123; testNums[j] = nums[i]; j=j+1; &#125; &#125; for(int l=0;l&lt;j;l++)&#123; for(int k=l+1;k&lt;j;k++)&#123; if(testNums[l]+testNums[k]==target)&#123; return new int[]&#123;l,k&#125;; &#125; &#125; &#125; return null; &#125;&#125; 没理解好题意，这种解法最后得到的是我们自定义数组的序号，而不是题目要求的序号，晕倒。。。后来发现一个更严重的问题。。他没有说过不能有负数！！！！也就不需要判断数组里的值是否大于和。。。 然后重新构思一下，先来个基本的解法 方法一：暴力循环123456789101112public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for (int i=0;i&lt;nums.length;i++)&#123; for(int k=i+1;k&lt;nums.length;k++)&#123; if(nums[i]+nums[k]==target)&#123; return new int[]&#123;i,k&#125;; &#125; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; 至于结果嘛，最简单的自然也高效不到哪里。 分析这个方法的原理很简单，就是将每一个值与其他的值循环遍历，看是否有符合条件的情况发生。稍微要注意的是 for(int k=i+1;k&lt;nums.length;k++) 这里k=i+1是为了避免前面循环过的情况再次循环一遍。时间复杂度 ： O(n^2) 。n个元素都要循环遍历数组内其余的元素，所以是n^2。空间复杂度 ： O(1) . 方法二：两次循环的 hash table123456789101112131415public class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; numbers.length; i++) &#123; map.put(numbers[i],i); &#125; for (int i = 0; i &lt; numbers.length; i++) &#123; int requestNum = target - numbers[i]; if (map.containsKey(requestNum)&amp;&amp;map.get(requestNum)!=i) &#123; return new int[]&#123;i,map.get(requestNum)&#125;; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125;&#125; 可以看到效率有了很大的提升。 分析这个方法的原理其实就是使用hash table 来将时间成本来替换空间成本，将一次复杂度为O(n)的循环变为接近O(1)的查找，为什么是接近呢，因为如果hash table发生大量的碰撞，就会导致复杂度向O(n)靠近。我们将数组里每一个元素的值作为key存入hash table，而将其序列号作为对应的value存入hash table，然后遍历数组查找是否有对应的值在hash table 的key中，有则取出该key对应的value。时间复杂度 ： O(n)空间复杂度 ： O(n) 方法三：一次循环的 hash table12345678910111213public class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; numbers.length; i++) &#123; int requestNum = target - numbers[i]; if (map.containsKey(requestNum)) &#123; return new int[]&#123;map.get(requestNum),i&#125;; &#125; map.put(numbers[i],i); &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125;&#125; 效率稍微提高了一些。。但是有些不能接受啊。怎么还只是在中间的位置。。。然后试了几次，大概在40%到50%徘徊，前面那些是用什么算的。。。为何那么快。理论上来说至少需要循环比对结果一次，也就是需要O(n)的复杂度。 分析这个方法的原理其实就是方法二的一个改善，因为我们不需要将全部的数组都放入hash table ，我们最终的目的是为了得到两个相加等于目标数的值的序号即可，所以我们在将数组里的值放入hash table 的时候就进行比对，一旦得到所需要的值立即结束循环。时间复杂度 ： O(n)空间复杂度 ： O(n) 如果你有更好的办法或者对我这里的描述有其他看法，请联系我。谢谢","categories":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/categories/Chinese/"},{"name":"Algorithm","slug":"Chinese/Algorithm","permalink":"http://yoursite.com/categories/Chinese/Algorithm/"},{"name":"LeetCode","slug":"Chinese/Algorithm/LeetCode","permalink":"http://yoursite.com/categories/Chinese/Algorithm/LeetCode/"}],"tags":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/tags/Chinese/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 1 Two Sum [English ver]","slug":"1-Two-Sum/Record[English ver]","date":"2017-02-16T16:00:00.000Z","updated":"2018-07-04T13:51:02.609Z","comments":true,"path":"2017/02/17/1-Two-Sum/Record[English ver]/","link":"","permalink":"http://yoursite.com/2017/02/17/1-Two-Sum/Record[English ver]/","excerpt":"[English ver]1 Two SumQuestionTwo SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.","text":"[English ver]1 Two SumQuestionTwo SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. First time, i got a wrong try.1234567891011121314151617181920public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] testNums = new int[nums.length]; int j = 0; for (int i=0;i&lt;nums.length;i++)&#123; if(nums[i]&lt;target)&#123; testNums[j] = nums[i]; j=j+1; &#125; &#125; for(int l=0;l&lt;j;l++)&#123; for(int k=l+1;k&lt;j;k++)&#123; if(testNums[l]+testNums[k]==target)&#123; return new int[]&#123;l,k&#125;; &#125; &#125; &#125; return null; &#125;&#125; I did not understand the meaning of problem , the last we get by this solution are the index of the array which we created , rather than the requirements of the index of he gave , fainted. . . Later i had found a more serious problem. . The problem did not say there can not be negative number ! . . . It is not necessary to determine whether the value of the array is bigger than the target number. . . And then i re-think about it, the first solution is a basic way. Approach 1：Brute Force123456789101112public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for (int i=0;i&lt;nums.length;i++)&#123; for(int k=i+1;k&lt;nums.length;k++)&#123; if(nums[i]+nums[k]==target)&#123; return new int[]&#123;i,k&#125;; &#125; &#125; &#125; throw new IllegalArgumentException(&quot;No two sum solution&quot;); &#125;&#125; for the results,uh Well, the simplest solution often means the less efficient way. AnalysisThe principle of this method is very simple, Loop through each element x and find if there is another value that plus x and then equals to target . you have to attention to “K = i + 1” of “for(int k=i+1;k&lt;nums.length;k++)” is in order to avoid the previous looped of the situation looped again. Time complexity: O (n ^ 2). For each element, we try to find its complement by looping through the rest of array which takes O(n). so it is n ^ 2.Space complexity: O (1). Approach 2 Two-pass Hash Table123456789101112131415public class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; numbers.length; i++) &#123; map.put(numbers[i],i); &#125; for (int i = 0; i &lt; numbers.length; i++) &#123; int requestNum = target - numbers[i]; if (map.containsKey(requestNum)&amp;&amp;map.get(requestNum)!=i) &#123; return new int[]&#123;i,map.get(requestNum)&#125;; &#125; &#125; throw new IllegalArgumentException(&quot;No two sum solution&quot;);&#125;&#125; You can see the efficiency has been greatly improved. AnalysisThe principle of this method is to use the hash table to replace the time cost of space costs, a complexity of O(n) change into near O(1) , why should i use “near”, because if the hash table has a lot Of collision occurredthe, it will lead to complexity to near O(n) . We use the value of each element in the array as a key into the hash table, and its index number as the key’s value into the hash table, and then traverse the array to find whether there is a corresponding value in the hash table key, if we find that, get the key’s value .Time complexity: O (n)Space complexity: O (n) Approach 3 One-pass Hash Table12345678910111213public class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; numbers.length; i++) &#123; int requestNum = target - numbers[i]; if (map.containsKey(requestNum)) &#123; return new int[]&#123;map.get(requestNum),i&#125;; &#125; map.put(numbers[i],i); &#125; throw new IllegalArgumentException(&quot;No two sum solution&quot;);&#125;&#125; The efficiency is slightly improved. But i can’t accept that how is it just in the middle efficiency of the whole approach. . . And then i tried several times, it is always in the about 40% to 50% position, these methods in front of this solution’s position how can they work?. . . Why so fast? Theoretically, it is necessary to loop the results at least once, that is, the complexity of O (n) is required. AnalysisThe principle of this method actually is an improvement of the method two, because we do not need to put all the arrays into the hash table, what we need is to get the sum of two number which equals to the number of the target number , so we check if current element’s complement already exists in the table when we put the array’s element into the hash table , once we find the required value we stop the loop.Time complexity: O (n)Space complexity: O (n) If you have a better method or have other opinions on the description of me here, please contact me. Thank you.","categories":[{"name":"English","slug":"English","permalink":"http://yoursite.com/categories/English/"},{"name":"Algorithm","slug":"English/Algorithm","permalink":"http://yoursite.com/categories/English/Algorithm/"},{"name":"LeetCode","slug":"English/Algorithm/LeetCode","permalink":"http://yoursite.com/categories/English/Algorithm/LeetCode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"English","slug":"English","permalink":"http://yoursite.com/tags/English/"}]},{"title":"Android 6.0的变化 （下）","slug":"Android-6.0-Change-2","date":"2016-08-20T15:31:40.000Z","updated":"2018-05-18T14:13:38.470Z","comments":true,"path":"2016/08/20/Android-6.0-Change-2/","link":"","permalink":"http://yoursite.com/2016/08/20/Android-6.0-Change-2/","excerpt":"","text":"目录 目录 浏览器书签变化 Android密钥库变化 wifi和网络工作的变化 照相服务改变 运行时 APK验证 USB连接 企业级Android的变化 DevicePolicyManager api的变化： 其他API的变化： 全局设置的变化： 浏览器书签变化这个版本移除了对全局书签的支持。android.provider.Browser.getAllBookmarks()and android.provider.Browser.saveBookmark() 方法现在被移除了。同样的，READ_HISTORY_BOOKMARKS and WRITE_HISTORY_BOOKMARKS 权限也被移除了。如果你的APP目标版本是Android 6.0 (API level 23) 或者更高，不要使用全局书签或使用全局书签的权限，相对应的，你的APP应该使用内部的书签。 Android密钥库变化在这个版本， Android Keystore provider 不在支持DSA.ECDSA仍然被支持。当安全锁屏被禁用或复位时（例如，被用户或设备管理器操作时），那些没加密的密钥将不再被删除，在这些时候那些加密的密钥将被删除。 wifi和网络工作的变化这个版本介绍了一下几个有关于Wi-Fi 和网络工作的API的行为变化。 你的APP现在可以改变 WifiConfiguration 对象的状态仅当是你创建了这些对象时。你将不被允许去修改或者删除WifiConfiguration 对象当他是被用户或者别的APP创建的。 在之前，如果一个APP使用 enableNetwork() 方法并设置disableAllOthers=true 来强制设备连接某个指定的WiFi网络，设备将会拒绝连接其他的网络比如蜂窝数据。在这个版本，设备不在拒绝连接其他的网络。如果你的APP的targetSdkVersion 是20或者更低，他将被固定在所选的WiFi网络。如果你的APP的targetSdkVersion 是21或者更高，使用多网络API（例如 openConnection(), bindSocket(),和新的bindProcessToNetwork() 方法）来确保网络通信是使用被选择的网络。 照相服务改变在这个版本中，接收摄像头服务和共享资源的模式已经从原来的“先到先服务”的模式转变为先服务高优先级的进程，服务的行为改变包括： 获取相机子系统的资源，包括打开和配置相机设备，是基于APP进程的“优先级”来进行授予的。用户可见的或者在最前的activity的APP进程通常给予较高的优先级，来使的相机资源的分配和使用更加的可靠。 一个低优先级的APP的正在使用相机的用户可能会被“驱逐”当一个高优先级的APP尝试使用相机时。在被弃用的Camera API中，这将导致被驱逐的用户将会调用 onError() 方法，而在Camera2 API中，这将导致被驱逐的用户调用 onDisconnected() 方法。 当设备拥有合适的照相机硬件时，不同的APP进程可以独立的打开和使用照相机设备。然而，多进程使用的情况下，当同时请求导致对任意的相机设备的性能和能力的降低，现在的相机服务对此进行检测并且禁止改行为。这样的改变可能导致低优先级的用户被“驱逐”即使没有其他的APP明确的尝试访问相同的相机设备。 改变当前的用户会导致之前的用户中的APP的活动的相机用户被驱逐。访问相机应用将被限制于用户配置文件属于当前设备用户者。在实践中，这就比如说是一个“游客”账户，当用户切换了一个不同的账号时将无法离开正在运行的相机子系统的进程。 运行时ART运行时可以正确的实现访问 newInstance()方法的规则。这种改变解决了以前版本中Dalvik 检查访问规则错误的问题。如果你的APP调用了 newInstance()方法并且你想要重写访问检查，应该调用 setAccessible()并将传入参数设为true。如果你的APP使用了v7 appcompat library 或者 v7 recyclerview library 包，你必须在你的APP里更新这些相应的包到最新版。此外，确保你的xml中引用的自定义类已经更新来保证他们的类构造器可用。 这个版本更新了动态连接器的行为。动态链接器现在可以识别库的soname和他的路径的不同（公共bug6670），并且实现了通过soname来进行查找的功能。在加载的时候那些先前工作在坏的 DT_NEEDED 的项目（在创建机器文件系统时使用绝对路径）可能会失败。 现在已经支持方法dlopen(3) RTLD_LOCAL模式，需要注意的是RTLD_LOCAL是默认值，当你没有明确使用其他参数时将不会影响到默认值。（除非你的APP明确的使用了 RTLD_GLOBAL）。在使用RTLD_LOCAL的情况下，比较晚使用dlopen(3）进行库加载的标识符将不可用。 在Android之前的版本里，如果你要求系统加载一个文本重定位的共享库文件，系统会显示警告但是仍然会允许加载该库。从这个版本开始，如果你的APP的目标sdk是23或者更高系统将会拒绝该库。为了帮助你检测到库文件的加载失败，你的APP应该打印有关日志来记录dlopen()失败，包括记录问题的描述以及dlerror返回。为了学习更多的有关文本重定位的内容可见这个指导。 APK验证现在平台执行严格的apk验证。一个在manifest中声明了某文件但是在apk中却没有出现该文件的apk被认为是损坏的。一个apk中的任何内容被修改后必须重新签名。 USB连接设备通过USB端口进行连接现在默认设置为仅充电模式。为了通过USB连接方式访问设备及其内容，用户必须明确的授予这种交互的权限。如果你的应用支持通过USB端口进行交互，请考虑到该交互必须显示的启用。 企业级Android的变化在这个版本包括了以下企业级Android的行为变化。 个人环境中的企业通讯录。当用户查看过去的通话记录时，google拨号器将会显示企业通讯录。设置setCrossProfileCallerIdDisabled() 为true来使得在google拨号器里隐藏企业联系人记录。当通过蓝牙分享时工作通讯录将会和个人通讯录一起显示，除非你 setBluetoothContactSharingDisabled() 为false。在默认情况下，它是设置为true的。 WiFi配置清除：通过Profile Owner来添加Wi-Fi配置（例如，调用addNetwork()方法）在它对应的企业配置文件被移除后删除。 WiFi配置锁定：如果WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN 不为0时，任何由活动设备拥有者创建的WiFi配置文件将不可以被用户进行修改和删除。用户仍然可以创建和修改他们自己的WiFi配置。活动设备所有者拥有修改和删除包括那些不是由他们创建的WiFi配置的特权。 通过google账号来下载企业策略控制器：当一个管理环境之外的需要管理的google账号要求通过设备策略控制器app添加到设备时，新增账号流程将会提示用户安装合适的WPC。这一行为同样支持通过设置-账号和初始化设备时添加账号。 DevicePolicyManager api的变化：调用 setCameraDisabled()方法只会影响当前调用相机的用户。从管理文件中调用的话并不影响正在主用户上运行的使用相机的APP。 此外，现在配置拥有者可以和设备拥有者一样使用setKeyguardDisabledFeatures() 方法。 配置拥有者可以设置以下锁屏设置：KEYGUARD_DISABLE_TRUST_AGENTS 和 KEYGUARD_DISABLE_FINGERPRINT可以影响配置文件的父用户。KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS,会影响APP在管理文件中产生的通知。 DevicePolicyManager.createAndInitializeUser() 和DevicePolicyManager.createUser()方法被弃用。 setScreenCaptureDisabled() 方法现在也会阻塞辅助框架当给定的用户在前台活动时。 EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM 现在默认SHA-256。SHA-1 现在仍然支持向后兼容但是以后将会被删除。 EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM现在只接受SHA-256。 Android 6.0 (API level 23)中的 Device initializer API 现在被删除了。 EXTRA_PROVISIONING_RESET_PROTECTION_PARAMETERS 被移除，所以NFC触碰配置不能以编程解锁一个恢复出厂设置保护的设备。 你现在可以使用EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE在NFC触碰时将管理设备的数据传输给设备拥有者的APP。 企业Android api 优化了M的运行时权限，包括工作文件，协助层，以及其他等等。新的 DevicePolicyManager 权限API不影响Android M 之前的APP版本。 当用户从初始化设置流程中通过ACTION_PROVISION_MANAGED_PROFILE 或 ACTION_PROVISION_MANAGED_DEVICE intent退出同步部分，系统现在会返回一个RESULT_CANCELED返回值。 其他API的变化：数据流量统计:android.app.usage.NetworkUsageStats 类被重命名为 NetworkStats. 全局设置的变化：以下属性将不能再通过 setGlobalSettings()来设置：BLUETOOTH_ONDEVELOPMENT_SETTINGS_ENABLEDMODE_RINGERNETWORK_PREFERENCEWIFI_ON 以下全局设置现在可以使用setGlobalSettings()来设置：WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN","categories":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/categories/Chinese/"},{"name":"Android","slug":"Chinese/Android","permalink":"http://yoursite.com/categories/Chinese/Android/"},{"name":"版本差异","slug":"Chinese/Android/版本差异","permalink":"http://yoursite.com/categories/Chinese/Android/版本差异/"}],"tags":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/tags/Chinese/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"版本差异","slug":"版本差异","permalink":"http://yoursite.com/tags/版本差异/"}]},{"title":"Android 6.0的变化 （上）","slug":"Android-6.0-Change-1","date":"2016-08-20T12:21:44.000Z","updated":"2018-05-18T14:08:52.524Z","comments":true,"path":"2016/08/20/Android-6.0-Change-1/","link":"","permalink":"http://yoursite.com/2016/08/20/Android-6.0-Change-1/","excerpt":"","text":"随着一系列新的特性以及功能， Android 6.0 (API level 23)包含了很多的系统变化以及API行为的变化。本文着重介绍了一些你应该理解的和占用APP中重要部分的变化。 如果你之前已经在Android平台发布过APP，要知道这些平台上的变化将会影响你的APP。 目录 目录 运行时权限 休眠和应用待机模式 移除Apache的 HTTP Client BoringSSL 获取硬件标识符 通知 AudioManager 改变 文本选择 运行时权限这个版本引入了一个新的权限模型，使得用户现在可以在运行时直接管理APP权限。这个模型改善了用户对权限管理的可见度和管理程度，并简化了APP开发者对安装和自动升级的流程。用户可以对已安装的APP的权限分别进行授权和取消。 当你的APP的目标版本在Android 6.0 (API level 23)或者更高的时候， 请确保在运行时检查并申请权限。要确定你的APP是否被授予了某权限，可以通过调用新的checkSelfPermission()方法。为了去申请一个权限，可以通过调用 requestPermissions() 新方法。即使你的APP目标版本不是 Android 6.0 (API level 23)，你也应该在新的权限模型下进行测试。 想要了解更多的在你的APP里支持新的权限模型的细节，可见 Working with System Permissions。获得更多的评估对你的APP的影响的提示，可见Permissions Best Practices。 危险权限和普通权限见下链接点击打开链接 休眠和应用待机模式这个版本将为空闲的设备和APP引入新的节能方式。这些新功能将会影响所有的APP，所以请确保你的APP在新的模式下进行测试。 休眠：如果用户拔出一个设备并将其屏幕关闭闲置一段时间，设备将会进入休眠模式，尝试使系统进入睡眠状态。在这个模式下，设备周期性的恢复短暂时间的正常操作使得APP可以进行同步，使得系统可以进行一些待执行的操作。 APP待机：APP待机允许系统判定一个APP是处于待机状态当这个APP没有被用户显式的使用。系统在用户一段时间内并没有触摸这个APP时做出这个决定。如果设备没有连接充电器，系统将会禁止访问网络并暂停APP的同步以及相应的工作当他被认为是闲置的时候。 学习更多的有关节能方面的改变，详见Optimizing for Doze and App Standby。 移除Apache的 HTTP ClientAndroid 6.0 的版本移除了对 Apache HTTP client的支持.如果你的APP正在使用这个client并且目标版本在Android 2.3 (API level 9)或者更高，请使用HttpURLConnection类来替代。这个API是更加高效的，因为他采用了透明压缩和响应缓存来减少网络使用，减少电能消耗。如果仍然想继续使用Apache HTTP APIs，你必须一开始就在你的build.gradle文件里定义以下编译时依赖。 123android &#123; useLibrary &apos;org.apache.http.legacy&apos;&#125; BoringSSLAndroid正在将OpenSSL替换为BoringSSL库。如果你的APP使用的是 Android NDK，请不要使用那些不属于NDK API里的库，比如：libcrypto.so 和 libssl.so.这些库不是公开的API,他们的修改和禁用也不会通过文件和设备通知开发者。另外，这样可能还会暴露你APP的安全漏洞。取而代之的是你需要修改你的native代码，通过JNI来调用Java cryptography APIs或者静态连接到你选择的加密库。 获取硬件标识符从这个版本开始，为了给用户提供更好点数据保护，Android删除了通过编程方式从Wi-Fi 和 Bluetooth APIs来获得硬件本地标识符的方法。现在 WifiInfo.getMacAddress() 和 BluetoothAdapter.getAddress()方法将始终返回一个常量值02:00:00:00:00:00。 为了通过蓝牙或WiFi扫描获取附近的设备的硬件标识符，你的APP必须拥有ACCESS_FINE_LOCATION 或 ACCESS_COARSE_LOCATION权限。 123WifiManager.getScanResults()BluetoothDevice.ACTION_FOUNDBluetoothLeScanner.startScan() 注意：当一个运行Android 6.0 (API level 23)的设备启动WiFi或者蓝牙扫描时，这个操作对外部设备是可见的，并会被初始化一个随机的mac地址。 通知这个版本删除了 Notification.setLatestEventInfo()方法。使用Notification.Builder来取代它进行构造通知。为了反复更新一个通知，可以重用 Notification.Builder 实例，调用 build() 方法来更新通知实例。 adb shell dumpsys notification命令不在打印你的通知文本。使用adb shell dumpsys notification –noredact命令来取代它打印你的通知对象文本。 AudioManager 改变不再支持通过 AudioManager类来对某个音频流进行精确的调音或者静音设置。 setStreamSolo()方法已经被弃用了，你应该使用 requestAudioFocus() 方法来替代它。同样的setStreamMute()方法也被弃用了，调用 adjustStreamVolume() 方法来替代它，传入的参数变为ADJUST_MUTE 或 ADJUST_UNMUTE 。 文本选择当用户在你的APP上选择文本时，你现在可以在浮动工具栏里显示一些文本选择动作比如剪切，复制，和粘贴。和用户的交互界面类似于上下文动作菜单，就像为单独的视图配置的上下文菜单。 为了实现文本选择的浮动工具栏，需要在你已有的APP里做出以下改变： 1.在你的view里或者activity里，改变你的 ActionMode 的获取方法，由startActionMode(Callback)变为 startActionMode(Callback, ActionMode.TYPE_FLOATING). 2.将你已经实现了ActionMode.Callback变为继承自ActionMode.Callback2。 3.重写 onGetContentRect()方法来提供视图中内容选中框（比如文本选中框）的坐标。 4.在矩形框作为一个唯一的元素不再有效时，调用 invalidateContentRect() 方法。 如果你在使用 Android Support Library revision 22.2, 你要知道浮动工具栏并不向后支持并且APP兼容会默认控制 ActionMode。这会阻止悬浮工具栏的显示。为了实现在 AppCompatActivity 里对 ActionMode的支持，调用 getDelegate()方法，并用其得到的 AppCompatDelegate 对象调用setHandleNativeActionModesEnabled()并将传入参数设为false。这个调用返回 ActionMode的控制给框架。在设备运行Android 6.0 (API level 23),这允许框架去支持 ActionBar 或者浮动工具栏模式，而当设备运行早Android 5.1 (API level 22)或更低的版本上时，只有 ActionBar 模式被支持。","categories":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/categories/Chinese/"},{"name":"Android","slug":"Chinese/Android","permalink":"http://yoursite.com/categories/Chinese/Android/"},{"name":"版本差异","slug":"Chinese/Android/版本差异","permalink":"http://yoursite.com/categories/Chinese/Android/版本差异/"}],"tags":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/tags/Chinese/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"版本差异","slug":"版本差异","permalink":"http://yoursite.com/tags/版本差异/"}]},{"title":"Android declare-styleable自定义属性","slug":"Android-declare-styleable-Attribute","date":"2016-03-17T07:24:26.000Z","updated":"2018-07-03T22:48:36.131Z","comments":true,"path":"2016/03/17/Android-declare-styleable-Attribute/","link":"","permalink":"http://yoursite.com/2016/03/17/Android-declare-styleable-Attribute/","excerpt":"","text":"我们自己定义view，通常继承View，重写构造方法和onDraw等函数，然后具体实现自己定义的复杂view。但是继承这个自定义view的有的属性又各有不同，有的属性在原生属性中没有，这时候就可以使用自定义的属性来便捷的设置相应的属性。 1、在res/values/下新建一个attrs.xml文件。写入这三级标签。并填入相应属性。 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"myStyle\"&gt; &lt;attr name=\"textSize\" format=\"dimension\" /&gt; &lt;attr name=\"backgroud\" format=\"reference\" /&gt; &lt;attr name=\"text\" format=\"string|reference\" /&gt; &lt;attr name=\"textColor\" format=\"color\" /&gt; &lt;attr name=\"yesOrNot\" format=\"boolean\" /&gt; &lt;attr name=\"number\"&gt; &lt;enum name=\"one\" value=\"0\" /&gt; &lt;enum name=\"two\" value=\"1\" /&gt; &lt;enum name=\"leftToRight\" value=\"2\" /&gt; &lt;enum name=\"topToBottom\" value=\"3\" /&gt; &lt;/attr&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 2、建立一个自定义视图类，本次偷懒直接继承自textview。然后使用typedarray类来获取控件相应的属性并使用。 123456789101112131415161718192021222324252627282930import android.content.Context;import android.content.res.TypedArray;import android.graphics.Color;import android.graphics.drawable.Drawable;import android.util.AttributeSet;import android.widget.TextView;public class MyView extends TextView&#123; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.myStyle); float textSize = typedArray.getDimension(R.styleable.myStyle_textSize, 15); Drawable back = typedArray.getDrawable(R.styleable.myStyle_backgroud); String textString = typedArray.getString(R.styleable.myStyle_text); int textColor = typedArray.getInt(R.styleable.myStyle_textColor, Color.BLACK); boolean yesOrNot = typedArray.getBoolean(R.styleable.myStyle_yesOrNot, true); int number = typedArray.getInt(R.styleable.myStyle_number, 0); setTextSize(textSize); setText(textString); setBackgroundDrawable(back); setTextColor(textColor); &#125;&#125; 3、在布局文件里引用该类，并设定相应的属性。记得要定义xmlns:myapp（后面的名称随意取，但要上下一致。）= “http://schemas.android.com/apk/res/com.example.declarestyleabletest&quot;（最后是该自定义视图类所在的包名） 1234567891011121314151617181920&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:myapp=\"http://schemas.android.com/apk/res/com.example.declarestyleabletest\" android:id=\"@+id/container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"com.example.declarestyleabletest.MainActivity\" tools:ignore=\"MergeRootFrame\" &gt; &lt;com.example.declarestyleabletest.MyView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" myapp:backgroud=\"@drawable/ic_launcher\" myapp:number=\"one\" myapp:text=\"sdfkks\" myapp:textColor=\"@color/black\" myapp:textSize=\"15sp\" /&gt;&lt;/LinearLayout&gt; 补充一些常用的format reference 指定某资源IDstring 字符串dimension 尺寸color 颜色boolean 布尔integer 整型float 浮点型fraction 百分数enum 枚举flag 位运算 xml 中定义好自己的属性值，在在代码中得到值，或使用默认值 1234567891011121314public CText(Context context, AttributeSet set) &#123; super(context, set); this.context = context; initView(); TypedArray array = context.obtainStyledAttributes(set,R.styleable.CEditText); initAttrs(array); &#125; private void initAttrs(TypedArray a) &#123; hint = a.getString(R.styleable.CEditText_cHint); text = a.getString(R.styleable.CEditText_cText); setAttrs(); a.recycle(); &#125;","categories":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/categories/Chinese/"},{"name":"Android","slug":"Chinese/Android","permalink":"http://yoursite.com/categories/Chinese/Android/"},{"name":"UI","slug":"Chinese/Android/UI","permalink":"http://yoursite.com/categories/Chinese/Android/UI/"},{"name":"Custom View","slug":"Chinese/Android/UI/Custom-View","permalink":"http://yoursite.com/categories/Chinese/Android/UI/Custom-View/"}],"tags":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/tags/Chinese/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"UI","slug":"UI","permalink":"http://yoursite.com/tags/UI/"},{"name":"Custom View","slug":"Custom-View","permalink":"http://yoursite.com/tags/Custom-View/"}]},{"title":"Byte 常用转换","slug":"Byte-Common-transition","date":"2016-03-08T16:00:00.000Z","updated":"2018-05-06T10:13:59.084Z","comments":true,"path":"2016/03/09/Byte-Common-transition/","link":"","permalink":"http://yoursite.com/2016/03/09/Byte-Common-transition/","excerpt":"思路:以 int 作为例子, 首先要知道他们的换算公式。 1 int = 4 byte ，1 byte = 8 bit , 一个 bit 是一位二进制。i 和 0xFF 取与得到最低位的 1byte 数据，然后将 i 右移8位再与 0xFF 取与得到第二低位的 1byte数据，以此类推。","text":"思路:以 int 作为例子, 首先要知道他们的换算公式。 1 int = 4 byte ，1 byte = 8 bit , 一个 bit 是一位二进制。i 和 0xFF 取与得到最低位的 1byte 数据，然后将 i 右移8位再与 0xFF 取与得到第二低位的 1byte数据，以此类推。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/** * 将int转换为四个字节的byte数组，高位在前，低位在后 * * @param i 要转换的int参数 * * @return 四个字节的byte数组 */ public static byte[] intToHlBytes4(int i) &#123; byte[] result = new byte[4]; result[3] = (byte) (i &amp; 0xFF); result[2] = (byte) ((i &gt;&gt; 8) &amp; 0xFF); result[1] = (byte) ((i &gt;&gt; 16) &amp; 0xFF); result[0] = (byte) ((i &gt;&gt; 24) &amp; 0xFF); return result; &#125; /** * 将int转换为四个字节的byte数组，低位在前，高位在后 * * @param i 要转换的int参数 * * @return 四个字节的byte数组 */ public static byte[] intTolhBytes4(int i) &#123; byte[] result = new byte[4]; result[0] = (byte) (i &amp; 0xFF); result[1] = (byte) ((i &gt;&gt; 8) &amp; 0xFF); result[2] = (byte) ((i &gt;&gt; 16) &amp; 0xFF); result[3] = (byte) ((i &gt;&gt; 24) &amp; 0xFF); return result; &#125; /** * 从byte数组的指定位置向后取出4位转为int数值，低位在前，高位在后 * * @param bs 原始数组 * * @param startSet 开始位 * * @return */ public static int hlBytesToInt(byte[] bs, int startSet) &#123; int result; result = (int) ((bs[startSet] &amp; 0xFF) | ((bs[startSet + 1] &amp; 0xFF) &lt;&lt; 8) | ((bs[startSet + 2] &amp; 0xFF) &lt;&lt; 16) | ((bs[startSet + 3] &amp; 0xFF) &lt;&lt; 24)); return result; &#125; /** * 从byte数组的指定位置向后取出4位转为int数值，高位在前，低位在后 * * @param bs 原始数组 * * @param startSet 开始位 * * @return */ public static int bytesToInt2(byte[] bs, int startSet) &#123; int result; result = (int) (((bs[startSet] &amp; 0xFF) &lt;&lt; 24) | ((bs[startSet + 1] &amp; 0xFF) &lt;&lt; 16) | ((bs[startSet + 2] &amp; 0xFF) &lt;&lt; 8) | (bs[startSet + 3] &amp; 0xFF)); return result; &#125; /** * long型转换为8字节的byte数组 高位在前低位在后 * * @param l long数据 * * @return */ public static byte[] longToHlBytes8(long l) &#123; byte[] result = new byte[8]; for (int i = 0; i &lt; 8; i++) &#123; int startSet = (result.length - 1 - i) * 8; result[i] = (byte) ((l &gt;&gt;&gt; startSet) &amp; 0xFF); &#125; return result; &#125; /** * short整数转换为2字节的byte数组 高位在前低位在后 * * @param s short整数 * * @return */ public static byte[] unsignedShortToByte2(int s) &#123; byte[] result = new byte[2]; result[0] = (byte) (s &gt;&gt; 8 &amp; 0xFF); result[1] = (byte) (s &amp; 0xFF); return result; &#125; /** * byte数组转换为无符号short整数 * * @param bs byte数组 * * @return */ public static int byte2ToUnsignedShort(byte[] bs) &#123; return byte2ToUnsignedShort(bs, 0); &#125; /** * byte数组转换为无符号short整数 * * @param bs byte数组 * * @param startSer 开始位置 * * @return */ public static int byte2ToUnsignedShort(byte[] bs, int startSer) &#123; int high = bs[startSer]; int low = bs[startSer + 1]; return (high &lt;&lt; 8 &amp; 0xFF00) | (low &amp; 0xFF); &#125; /** * byte数组转换为int整数 * * @param bs byte数组 * * @param startSet 开始位置 * * @return int整数 */ public static int byte4ToInt(byte[] bs, int startSet) &#123; int b0 = bs[startSet] &amp; 0xFF; int b1 = bs[startSet + 1] &amp; 0xFF; int b2 = bs[startSet + 2] &amp; 0xFF; int b3 = bs[startSet + 3] &amp; 0xFF; return (b0 &lt;&lt; 24) | (b1 &lt;&lt; 16) | (b2 &lt;&lt; 8) | b3; &#125;","categories":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/categories/Chinese/"},{"name":"Java","slug":"Chinese/Java","permalink":"http://yoursite.com/categories/Chinese/Java/"},{"name":"Data Structure","slug":"Chinese/Java/Data-Structure","permalink":"http://yoursite.com/categories/Chinese/Java/Data-Structure/"}],"tags":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/tags/Chinese/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}]}]}