{"meta":{"title":"LeonChen's Blog","subtitle":null,"description":null,"author":"LeonChen","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-03-11T13:24:26.000Z","updated":"2018-03-11T13:36:27.196Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"about","date":"2018-03-11T13:24:38.000Z","updated":"2018-03-11T13:24:38.958Z","comments":true,"path":"about/index-1.html","permalink":"http://yoursite.com/about/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2018-03-11T04:11:41.000Z","updated":"2018-03-11T04:19:15.835Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-03-11T04:11:35.000Z","updated":"2018-03-11T04:18:23.561Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"APP 版本控制","slug":"APP-Version-Control","date":"2018-04-12T16:00:00.000Z","updated":"2018-04-14T07:53:59.801Z","comments":true,"path":"2018/04/13/APP-Version-Control/","link":"","permalink":"http://yoursite.com/2018/04/13/APP-Version-Control/","excerpt":"","text":"版本管理是app的一个重要部分，他主要的用途有： 让用户了解当前的版本信息，了解升级或者降级信息等 不同的版本可能提供的服务和功能有所差别，版本信息可以给我们一个标志来识别当前版本可提供的服务和功能。 设置版本信息官方推荐是在Gradle中进行版本设置，因为Gradle中设置的版本信息会在构建的时候合并到manifest文件中，并会替换掉manifest中有关版本信息的设置。并且在Gradle中进行设置的话还可以根据应用不同的Flavor进行不同的设置。 版本控制主要有这么两个属性： -versionCode ： 整数，是内部版本号，仅用于判断一个版本是否比另一个版本新，用户并不会看到。通常是跟随着发布版本增加该code。 -versionName : 字符串，用户能看到的版本号。 通常我们将这些设置放在gradle下的android {} 块内部使用defaultConfig {} 包裹它。要注意，如果你在productFlavors中定义了这些属性，他们会覆盖defaultConfig中的值。 1234567891011121314151617android &#123; ... defaultConfig &#123; ... versionCode 1 versionName &quot;1.0.0&quot; &#125; productFlavors &#123; a &#123; ... versionName &quot;1.0.0&quot; &#125; b &#123; ... &#125; &#125;&#125; 在android中使用 PackageManager 的 getPackageInfo(java.lang.String, int) 方法可以获取版本信息。 1234567891011public static String getVersion(Context context)//获取版本号 &#123; try &#123; PackageInfo pi=context.getPackageManager().getPackageInfo(context.getPackageName(), 0); return pi.versionName; &#125; catch (NameNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return context.getString(R.string.version_unknown); &#125; &#125; 1234567891011public static int getVersionCode(Context context)//获取版本号(内部识别号)&#123; try &#123; PackageInfo pi=context.getPackageManager().getPackageInfo(context.getPackageName(), 0); return pi.versionCode; &#125; catch (NameNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return 0; &#125;&#125; 如果使用 Instant Run，Android Studio 会自动将 versionCode 设置为 MAXINT，将 versionName 设置为 INSTANTRUN。 统一配置顺便说一下一个可以统一所有的配置在一个地方的方法，这样可以便于我们管理版本。首先在主工程的build.gradle里增加一个配置区 12345678910ext &#123; // Sdk and tools minSdkVersion = 17 targetSdkVersion = 21 compileSdkVersion = 23 buildToolsVersion = &quot;23.0.3&quot; // App dependencies supportLibraryVersion = &apos;23.3.0&apos;&#125; 然后在module的build.gradle里使用123targetSdkVersion rootProject.ext.targetSdkVersioncompile &quot;com.android.support:appcompat-v7:$rootProject.supportLibraryVersion&quot; 123456789101112/** * 判断当前应用是否是debug状态 */public static boolean isApkInDebug(Context context) &#123; try &#123; ApplicationInfo info = context.getApplicationInfo(); return (info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0; &#125; catch (Exception e) &#123; return false; &#125;&#125; 1234567891011121314151617/***检测其他应用是否处于debug模式。*/public static boolean isApkDebugable(Context context,String packageName) &#123; try &#123; PackageInfo pkginfo = context.getPackageManager().getPackageInfo( packageName, 1); if (pkginfo != null ) &#123; ApplicationInfo info= pkginfo.applicationInfo; return (info.flags&amp;ApplicationInfo.FLAG_DEBUGGABLE)!=0; &#125; &#125; catch (Exception e) &#123; &#125; return false; &#125; Referencehttps://developer.android.com/studio/publish/versioning.html","categories":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/categories/Chinese/"},{"name":"Android","slug":"Chinese/Android","permalink":"http://yoursite.com/categories/Chinese/Android/"},{"name":"版本管理","slug":"Chinese/Android/版本管理","permalink":"http://yoursite.com/categories/Chinese/Android/版本管理/"}],"tags":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/tags/Chinese/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"版本管理","slug":"版本管理","permalink":"http://yoursite.com/tags/版本管理/"}]},{"title":"Android 相关错误及解决办法","slug":"Android-Error-And-Solution","date":"2018-01-10T14:15:10.000Z","updated":"2018-04-14T06:59:32.407Z","comments":true,"path":"2018/01/10/Android-Error-And-Solution/","link":"","permalink":"http://yoursite.com/2018/01/10/Android-Error-And-Solution/","excerpt":"","text":"问题 : Unable to instantiate activity ComponentInfo{com.xxxx.xxxx/com.xxxx.xxxx.LoginActivity}java.lang.RuntimeException: Unable to instantiate activity ComponentInfo{com.xxxx.xxxx/com.xxxx.xxxx.LoginActivity}: java.lang.ClassNotFoundException: Didn’t find class “com.xxxx.xxxx.LoginActivity” on path: /data/app/com.xxxx.xxxx-1. 解决方法 : 原因AndroidManifest.xml文件出错。将问题Activity的name具体到某个包下即可运行。android:name=”.LogoActivity”改为android:name=”.ac.LogoActivity”.","categories":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/categories/Chinese/"},{"name":"Android","slug":"Chinese/Android","permalink":"http://yoursite.com/categories/Chinese/Android/"},{"name":"Error","slug":"Chinese/Android/Error","permalink":"http://yoursite.com/categories/Chinese/Android/Error/"}],"tags":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/tags/Chinese/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Error","slug":"Error","permalink":"http://yoursite.com/tags/Error/"}]},{"title":"Byte 常用转换","slug":"Byte-Common-transition","date":"2016-03-08T16:00:00.000Z","updated":"2018-05-06T09:25:27.771Z","comments":true,"path":"2016/03/09/Byte-Common-transition/","link":"","permalink":"http://yoursite.com/2016/03/09/Byte-Common-transition/","excerpt":"","text":"思路:以 int 作为例子, 首先要知道他们的换算公式。 1 int = 4 byte ，1 byte = 8 bit , 一个 bit 是一位二进制。i 和 0xFF 取与得到最低位的 1byte 数据，然后将 i 右移8位再与 0xFF 取与得到第二低位的 1byte数据，以此类推。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/** * 将int转换为四个字节的byte数组，高位在前，低位在后 * * @param i 要转换的int参数 * * @return 四个字节的byte数组 */ public static byte[] intToHlBytes4(int i) &#123; byte[] result = new byte[4]; result[3] = (byte) (i &amp; 0xFF); result[2] = (byte) ((i &gt;&gt; 8) &amp; 0xFF); result[1] = (byte) ((i &gt;&gt; 16) &amp; 0xFF); result[0] = (byte) ((i &gt;&gt; 24) &amp; 0xFF); return result; &#125; /** * 将int转换为四个字节的byte数组，低位在前，高位在后 * * @param i 要转换的int参数 * * @return 四个字节的byte数组 */ public static byte[] intTolhBytes4(int i) &#123; byte[] result = new byte[4]; result[0] = (byte) (i &amp; 0xFF); result[1] = (byte) ((i &gt;&gt; 8) &amp; 0xFF); result[2] = (byte) ((i &gt;&gt; 16) &amp; 0xFF); result[3] = (byte) ((i &gt;&gt; 24) &amp; 0xFF); return result; &#125; /** * 从byte数组的指定位置向后取出4位转为int数值，低位在前，高位在后 * * @param bs 原始数组 * * @param startSet 开始位 * * @return */ public static int hlBytesToInt(byte[] bs, int startSet) &#123; int result; result = (int) ((bs[startSet] &amp; 0xFF) | ((bs[startSet + 1] &amp; 0xFF) &lt;&lt; 8) | ((bs[startSet + 2] &amp; 0xFF) &lt;&lt; 16) | ((bs[startSet + 3] &amp; 0xFF) &lt;&lt; 24)); return result; &#125; /** * 从byte数组的指定位置向后取出4位转为int数值，高位在前，低位在后 * * @param bs 原始数组 * * @param startSet 开始位 * * @return */ public static int bytesToInt2(byte[] bs, int startSet) &#123; int result; result = (int) (((bs[startSet] &amp; 0xFF) &lt;&lt; 24) | ((bs[startSet + 1] &amp; 0xFF) &lt;&lt; 16) | ((bs[startSet + 2] &amp; 0xFF) &lt;&lt; 8) | (bs[startSet + 3] &amp; 0xFF)); return result; &#125; /** * long型转换为8字节的byte数组 高位在前低位在后 * * @param l long数据 * * @return */ public static byte[] longToHlBytes8(long l) &#123; byte[] result = new byte[8]; for (int i = 0; i &lt; 8; i++) &#123; int startSet = (result.length - 1 - i) * 8; result[i] = (byte) ((l &gt;&gt;&gt; startSet) &amp; 0xFF); &#125; return result; &#125; /** * short整数转换为2字节的byte数组 高位在前低位在后 * * @param s short整数 * * @return */ public static byte[] unsignedShortToByte2(int s) &#123; byte[] result = new byte[2]; result[0] = (byte) (s &gt;&gt; 8 &amp; 0xFF); result[1] = (byte) (s &amp; 0xFF); return result; &#125; /** * byte数组转换为无符号short整数 * * @param bs byte数组 * * @return */ public static int byte2ToUnsignedShort(byte[] bs) &#123; return byte2ToUnsignedShort(bs, 0); &#125; /** * byte数组转换为无符号short整数 * * @param bs byte数组 * * @param startSer 开始位置 * * @return */ public static int byte2ToUnsignedShort(byte[] bs, int startSer) &#123; int high = bs[startSer]; int low = bs[startSer + 1]; return (high &lt;&lt; 8 &amp; 0xFF00) | (low &amp; 0xFF); &#125; /** * byte数组转换为int整数 * * @param bs byte数组 * * @param startSet 开始位置 * * @return int整数 */ public static int byte4ToInt(byte[] bs, int startSet) &#123; int b0 = bs[startSet] &amp; 0xFF; int b1 = bs[startSet + 1] &amp; 0xFF; int b2 = bs[startSet + 2] &amp; 0xFF; int b3 = bs[startSet + 3] &amp; 0xFF; return (b0 &lt;&lt; 24) | (b1 &lt;&lt; 16) | (b2 &lt;&lt; 8) | b3; &#125;","categories":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/categories/Chinese/"},{"name":"Java","slug":"Chinese/Java","permalink":"http://yoursite.com/categories/Chinese/Java/"},{"name":"Data Structure","slug":"Chinese/Java/Data-Structure","permalink":"http://yoursite.com/categories/Chinese/Java/Data-Structure/"}],"tags":[{"name":"Chinese","slug":"Chinese","permalink":"http://yoursite.com/tags/Chinese/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}]}]}